<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Next Token Visualization</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg0:#f4f7f9;
      --bg1:#eef5f7;
      --panel: rgba(255,255,255,.9);
      --panelSolid:#ffffff;
      --text:#0f172a;
      --muted:#64748b;
      --border: rgba(15,23,42,.12);
      --shadow: none;
      --shadow2: none;
      --radius: 18px;
      --radius2: 14px;
      --accent-rgb: 0,89,209;       /* blue */
      --accent2-rgb: 82,182,154;     /* teal */
      --accent3-rgb: 245,158,11;     /* amber */
      --accent: rgb(var(--accent-rgb));
      --accent2: rgb(var(--accent2-rgb));
      --accent3: rgb(var(--accent3-rgb));
      --specialBg: rgba(var(--accent3-rgb),.22);
      --specialBorder: rgba(var(--accent3-rgb),.45);
      --specialText: #92400e;
      --token-stack-width: 210px;
      --llm-width: 210px;
      --gap-min: 16px;
      --llm-stub: 54px;
      --llm-gap: calc(var(--llm-stub) + 8px);
      --danger:#ef4444;
      --ok:#22c55e;
      --wire: var(--accent);
      --wire2: var(--accent2);
    }

    *, *::before, *::after{
      box-sizing:border-box;
      box-shadow:none !important;
    }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color: var(--text);
      background:
        radial-gradient(1200px 600px at 20% 10%, var(--bg1), transparent 60%),
        radial-gradient(1000px 500px at 90% 20%, #eef1f6, transparent 55%),
        linear-gradient(180deg, var(--bg0), #ffffff);
      overflow:hidden;
    }

    .app{
      height:100%;
      display:flex;
      gap:16px;
      padding:16px;
    }

    /* Sidebar */
    .sidebar{
      width: 340px;
      min-width: 340px;
      display:flex;
      flex-direction:column;
      gap:14px;
    }

    .card{
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow2);
      padding: 14px 14px;
      backdrop-filter: blur(10px);
    }

    .card h3{
      margin:0 0 10px 0;
      font-size: 14px;
      letter-spacing:.2px;
      color: rgba(20,24,39,.85);
      font-weight: 700;
    }
    .cardHeader{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
      margin-bottom: 10px;
    }
    .cardHeader h3{
      margin:0;
    }
    .cardToggle{
      border: 1px solid var(--border);
      background: rgba(255,255,255,.8);
      border-radius: 999px;
      padding: 4px 6px;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
      transition: transform .12s ease, border-color .18s ease;
    }
    .cardToggle svg{ width:14px; height:14px; }
    .cardToggle:hover{
      transform: translateY(-1px);
      border-color: rgba(var(--accent-rgb),.25);
    }
    .card.collapsed{
      padding-bottom: 10px;
    }
    .card.collapsed .cardBody{
      display:none;
    }

    .row{
      display:flex;
      gap:10px;
      align-items:center;
    }
    .toggleRow{
      display:flex;
      align-items:center;
      gap:8px;
      font-size: 13px;
      font-weight: 700;
      color: rgba(20,24,39,.75);
    }
    .toggleRow input[type="checkbox"]{
      width:16px;
      height:16px;
      accent-color: var(--accent);
    }
    .col{
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .spacer{ flex:1; }

    label{
      font-size: 12px;
      font-weight: 600;
      color: rgba(20,24,39,.75);
    }
    .inputBlock{
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    .inputBlock + .inputBlock{
      margin-top: 8px;
    }

    input[type="text"], input[type="number"], textarea, select{
      width:100%;
      background: rgba(255,255,255,.92);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 10px 12px;
      font-size: 14px;
      color: var(--text);
      outline: none;
      box-shadow: 0 4px 14px rgba(20,24,39,.06);
      transition: box-shadow .18s ease, border-color .18s ease, transform .18s ease;
    }
    input[type="text"]:focus, input[type="number"]:focus, textarea:focus{
      border-color: rgba(var(--accent-rgb),.55);
      box-shadow: none;
    }
    textarea{ resize: vertical; min-height: 64px; }

    .btn{
      border: 0;
      border-radius: 14px;
      padding: 10px 12px;
      font-size: 14px;
      font-weight: 700;
      cursor:pointer;
      background: rgba(var(--accent-rgb),.10);
      color: rgba(15,23,42,1);
      transition: transform .12s ease, box-shadow .18s ease, background .18s ease;
      user-select:none;
    }
    .btn:hover{ transform: translateY(-1px); box-shadow: 0 14px 30px rgba(20,24,39,.10); }
    .btn:active{ transform: translateY(0px) scale(.99); }
    .btn:disabled{
      opacity: .5;
      cursor: not-allowed;
      transform: none;
    }
    .btn:disabled:hover{
      transform: none;
      box-shadow: none;
    }

    .btn.primary{
      background: var(--accent);
      color: white;
    }
    .btn.ghost{
      background: rgba(255,255,255,.65);
      color: rgba(20,24,39,.82);
      border: 1px solid var(--border);
      box-shadow: none;
    }
    .btn.danger{
      background: rgba(239,68,68,.12);
      color: rgba(120,25,25,1);
    }

    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,.80);
      box-shadow: 0 6px 18px rgba(20,24,39,.06);
      font-size: 13px;
      font-weight: 700;
      color: rgba(20,24,39,.75);
      user-select:none;
    }
    .pill.ok{ background: rgba(34,197,94,.12); color: rgba(17,88,49,1); border-color: rgba(34,197,94,.18); }
    .pill.warn{ background: rgba(251,191,36,.18); color: rgba(120,74,10,1); border-color: rgba(251,191,36,.25); }
    .pill.bad{ background: rgba(239,68,68,.14); color: rgba(110,20,20,1); border-color: rgba(239,68,68,.22); }

    .segmented{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
    }
    .segmented .btn{
      padding: 8px 10px;
      border-radius: 999px;
      font-size: 13px;
      font-weight: 800;
      box-shadow: none;
      border: 1px solid var(--border);
      background: rgba(255,255,255,.65);
    }
    .segmented .btn.active{
      background: rgba(var(--accent-rgb),.14);
      border-color: rgba(var(--accent-rgb),.35);
    }

    .sliderRow{
      display:flex;
      align-items:center;
      gap:10px;
    }
    input[type="range"]{
      width:100%;
      accent-color: var(--accent);
    }
    .smallVal{
      width: 74px;
      text-align:right;
      font-variant-numeric: tabular-nums;
      font-size: 12px;
      color: rgba(20,24,39,.68);
      font-weight: 700;
    }

    /* Main */
    .main{
      flex:1;
      min-width: 900px;
      display:flex;
      flex-direction:column;
      gap:14px;
    }

    .titleBar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding: 14px 18px;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow2);
      backdrop-filter: blur(10px);
    }
    .titleBar h1{
      margin:0;
      font-size: 18px;
      font-weight: 800;
      letter-spacing: .2px;
    }
    .titleBar .sub{
      font-size: 12px;
      color: var(--muted);
      font-weight: 600;
    }

    .viz{
      flex:1;
      min-height: 0;
      background: rgba(255,255,255,.55);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      position:relative;
      overflow:hidden;
    }

    .vizGrid{
      position:absolute;
      inset:0;
      display:grid;
      grid-template-columns:
        420px
        minmax(var(--gap-min), 1fr)
        var(--token-stack-width)
        var(--llm-gap)
        var(--llm-width)
        var(--llm-gap)
        minmax(460px, 2fr);
      row-gap: 14px;
      column-gap: 0;
      padding: 16px;
      min-height:0;
    }
    .leftCol{ grid-column: 1; min-width:0; display:flex; flex-direction:column; }
    .leftCol .branches{ flex:1; }
    .tokenStack{ grid-column: 3; }
    .llm{ grid-column: 5; }
    .dist{ grid-column: 7; min-width:0; }

    /* Branches */
    .branches{
      display:flex;
      flex-direction:column;
      gap: 12px;
      min-height:0;
      overflow:auto;
      padding-right: 6px;
    }

    .branch{
      background: rgba(255,255,255,.80);
      border: 1px solid var(--border);
      border-radius: 18px;
      box-shadow: 0 12px 30px rgba(20,24,39,.07);
      padding: 12px 12px;
      transition: transform .18s ease, opacity .18s ease, filter .18s ease, box-shadow .18s ease, border-color .18s ease;
      position:relative;
    }
    .branch.inactive{
      opacity:.55;
      filter: grayscale(.15);
    }
    .branch.active{
      border-color: rgba(var(--accent-rgb),.35);
    }
    .branchHeader{
      display:flex;
      align-items:center;
      gap:10px;
      margin-bottom: 10px;
    }
    .branchTitle{
      font-weight: 800;
      font-size: 13px;
      color: rgba(20,24,39,.85);
    }
    .branchMeta{
      font-size: 12px;
      color: rgba(20,24,39,.55);
      font-weight: 700;
    }

    .forkBtn{
      margin-left:auto;
      padding: 8px 10px;
      border-radius: 999px;
      font-weight: 800;
      font-size: 13px;
      background: rgba(var(--accent2-rgb),.14);
      color: rgba(15,75,70,1);
      border: 1px solid rgba(var(--accent2-rgb),.22);
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:6px;
      line-height: 1;
    }
    .forkBtn svg{ width:16px; height:16px; display:block; }
    .forkBtn:hover{
      box-shadow: none;
    }

    .iconBtn{
      padding: 7px 9px;
      border-radius: 999px;
      border: 1px solid rgba(20,24,39,.12);
      background: rgba(255,255,255,.70);
      box-shadow: none;
      cursor:pointer;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      transition: transform .12s ease, box-shadow .18s ease, border-color .18s ease;
    }
    .iconBtn svg{ width:16px; height:16px; }
    .iconBtn:hover{
      transform: translateY(-1px);
      box-shadow: none;
      border-color: rgba(var(--accent-rgb),.25);
    }

    .branch textarea{
      min-height: 76px;
      max-height: 240px;
      line-height: 1.4;
      font-size: 15px;
      font-weight: 600;
      border-radius: 14px;
      background: rgba(255,255,255,.92);
    }
    .branch textarea.systemPrompt{
      min-height: 52px;
      font-size: 14px;
    }

    .tokenWrap{
      margin-top: 10px;
      display:flex;
      flex-wrap:wrap;
      gap: 8px;
    }
    .tok{
      display:inline-flex;
      align-items:center;
      padding: 7px 10px;
      border-radius: 999px;
      border: 1px solid rgba(20,24,39,.12);
      background: rgba(246,247,255,.65);
      box-shadow: 0 8px 22px rgba(20,24,39,.06);
      font-size: 13px;
      font-weight: 800;
      color: rgba(20,24,39,.78);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      white-space: pre;
      transition: transform .15s ease, opacity .15s ease;
    }
    .tok.gen{
      background: rgba(var(--accent2-rgb),.14);
      border-color: rgba(var(--accent2-rgb),.25);
      color: rgba(13,81,76,1);
    }
    .tok.delete{
      cursor: pointer;
      transition: transform .12s ease, box-shadow .18s ease, border-color .18s ease, background .18s ease, color .18s ease;
    }
    .tok.delete:hover{
      background: rgba(239,68,68,.16);
      border-color: rgba(239,68,68,.32);
      color: rgba(110,20,20,1);
      box-shadow: 0 12px 26px rgba(239,68,68,.14);
      transform: translateY(-1px);
    }
    .tok.special{
      background: var(--specialBg);
      border-color: var(--specialBorder);
      color: var(--specialText);
    }
    .tok.attrHeat{
      background-color: rgba(var(--accent-rgb), var(--attr-alpha, 0));
      border-color: rgba(var(--accent-rgb), .55);
      color: rgba(15,23,42,.9);
    }
    .tok.newTok{
      animation: popIn .22s ease-out;
    }
    @keyframes popIn{
      0%{ transform: translateY(4px) scale(.96); opacity:0; }
      100%{ transform: translateY(0) scale(1); opacity:1; }
    }

    .dividerTok{
      padding: 7px 10px;
      border-radius: 999px;
      border: 1px dashed rgba(20,24,39,.18);
      background: rgba(255,255,255,.55);
      color: rgba(20,24,39,.52);
      font-weight: 900;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
    }

    .addBranchRow{
      margin-top: 8px;
      display:flex;
      gap:10px;
      align-items:center;
    }

    /* Center / tokens + LLM */
    .center{
      display: contents;
    }

    .tokenStack{
      width: var(--token-stack-width);
      flex: 0 0 var(--token-stack-width);
      background: transparent;
      border: 0;
      border-radius: 0;
      box-shadow: none;
      padding: 0;
      overflow:auto;
    }
    .tokenStackTitle{
      display:none;
    }
    .stackCol{
      display:flex;
      flex-direction:column;
      gap: 8px;
    }
    .stackTok{
      background: rgba(246,247,255,.75);
      border: 1px solid rgba(20,24,39,.12);
      border-radius: 14px;
      padding: 8px 10px;
      box-shadow: 0 10px 26px rgba(20,24,39,.06);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      white-space: pre;
      font-size: 13px;
      font-weight: 900;
      color: rgba(20,24,39,.78);
    }
    .stackTok.toggle{
      cursor: pointer;
      transition: transform .12s ease, box-shadow .18s ease, border-color .18s ease;
    }
    .stackTok.toggle:hover{
      transform: translateY(-1px);
      box-shadow: none;
      border-color: rgba(var(--accent-rgb),.25);
    }
    .stackTok.delete{
      cursor: pointer;
      transition: transform .12s ease, box-shadow .18s ease, border-color .18s ease, background .18s ease, color .18s ease;
    }
    .stackTok.delete:hover{
      background: rgba(239,68,68,.16);
      border-color: rgba(239,68,68,.32);
      color: rgba(110,20,20,1);
      box-shadow: 0 14px 30px rgba(239,68,68,.16);
    }
    .stackTok.summary{
      background: rgba(255,255,255,.85);
      border-style: dashed;
      color: rgba(20,24,39,.62);
      font-weight: 800;
    }
    .stackTok.gen{
      background: rgba(var(--accent2-rgb),.14);
      border-color: rgba(var(--accent2-rgb),.24);
      color: rgba(13,81,76,1);
    }
    .stackTok.special{
      background: var(--specialBg);
      border-color: var(--specialBorder);
      color: var(--specialText);
    }

    .llm{
      flex: 0 0 var(--llm-width);
      width: var(--llm-width);
      background: rgba(var(--accent-rgb), .35);
      border: 1px solid rgba(var(--accent-rgb), .5);
      border-radius: var(--radius);
      display:flex;
      align-items:center;
      justify-content:center;
      font-size: 22px;
      font-weight: 900;
      color: #03045e;
      position:relative;
      overflow:hidden;
      cursor: pointer;
    }
    .llm.off{
      background: rgba(var(--accent-rgb), .08);
      border-color: rgba(15,23,42,.12);
      color: rgba(100,116,139,.9);
    }
    .llm.off span{
      text-decoration: line-through;
    }
    .llm span{
      position:relative;
      z-index:1;
      letter-spacing:.8px;
    }

    /* Distribution */
    .dist{
      display:flex;
      flex-direction:column;
      gap: 12px;
      min-height:0;
    }
    .dist.off{
      opacity: .45;
      filter: grayscale(.35);
      pointer-events: none;
    }

    .distTop{
      display:flex;
      align-items:center;
      gap: 12px;
      padding: 12px 14px;
      background: rgba(255,255,255,.70);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: 0 10px 28px rgba(20,24,39,.08);
    }
    .distTop .title{
      font-weight: 900;
      letter-spacing:.2px;
    }
    .distTop .kLabel{
      font-size: 12px;
      font-weight: 900;
      color: rgba(20,24,39,.55);
    }
    .distTop input{
      width: 80px;
      padding: 10px 10px;
      border-radius: 12px;
      font-weight: 800;
      font-variant-numeric: tabular-nums;
    }

    .legend{
      display:flex;
      gap: 12px;
      flex-wrap:wrap;
      align-items:center;
      padding: 0 4px;
      color: rgba(20,24,39,.58);
      font-size: 12px;
      font-weight: 800;
    }
    .dot{
      width: 12px; height: 12px;
      border-radius: 999px;
      display:inline-block;
      margin-right: 6px;
      vertical-align: middle;
    }
    .dot.base{ background: rgba(20,24,39,.14); border: 1px solid rgba(20,24,39,.16); }
    .dot.final{ background: rgba(var(--accent-rgb),.65); border: 1px solid rgba(var(--accent-rgb),.25); }

    .bars{
      flex:1;
      min-height:0;
      overflow:auto;
      padding-right: 6px;
      padding-top: 1px;
    }

    .barRow{
      display:grid;
      grid-template-columns: 140px 1fr 88px;
      gap: 10px;
      align-items:center;
      padding: 10px 12px;
      border: 1px solid rgba(20,24,39,.10);
      background: rgba(255,255,255,.74);
      border-radius: 16px;
      box-shadow: 0 10px 24px rgba(20,24,39,.06);
      margin-bottom: 10px;
      cursor:pointer;
      transition: transform .12s ease, box-shadow .18s ease, border-color .18s ease;
    }
    .barRow:hover{
      transform: translateY(-1px);
      box-shadow: none;
      border-color: rgba(var(--accent-rgb),.22);
    }
    .barRow.selected{
      border-color: rgba(var(--accent-rgb),.35);
      box-shadow: none;
    }
    .barRow.greedyPick{
      border-color: rgba(var(--accent3-rgb),.55);
      background: rgba(var(--accent3-rgb),.08);
    }
    .barRow.greedyPick .barFinal{
      background: rgba(var(--accent3-rgb),.85);
    }
    .barRow.cut{
      opacity: .55;
      filter: grayscale(.2);
    }
    .barRow.cut .barFinal{
      background: rgba(20,24,39,.18);
      box-shadow: none;
    }
    .barRow.invalid{
      opacity: .38;
      filter: grayscale(.65);
      cursor: not-allowed;
    }
    .barRow.invalid:hover{
      transform: none;
      border-color: rgba(20,24,39,.10);
      box-shadow: none;
    }
    .barRow.invalid .barFinal{
      background: rgba(20,24,39,.14);
    }

    .barTok{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-weight: 900;
      font-size: 13px;
      white-space: nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
      color: rgba(20,24,39,.78);
    }
    .barTok.special{
      color: var(--specialText);
    }
    .barWrap{
      position:relative;
      height: 16px;
      border-radius: 999px;
      background: rgba(20,24,39,.06);
      overflow:hidden;
    }
    .barBase, .barFinal{
      position:absolute;
      top:0; bottom:0;
      left:0;
      border-radius: 999px;
      width: 0%;
      transition: width .42s cubic-bezier(.2,.9,.2,1);
    }
    .barBase{
      background: rgba(20,24,39,.14);
    }
    .barFinal{
      background: rgba(var(--accent-rgb),.85);
      box-shadow: none;
    }
    .barProb{
      text-align:right;
      font-variant-numeric: tabular-nums;
      font-size: 13px;
      font-weight: 900;
      color: rgba(20,24,39,.62);
    }

    .otherRow{
      border-style: dashed;
      background: rgba(255,255,255,.58);
      cursor: default;
    }
    .otherRow:hover{ transform:none; box-shadow: 0 10px 24px rgba(20,24,39,.06); border-color: rgba(20,24,39,.10); }
    .otherRow .barFinal{ background: rgba(var(--accent-rgb),.35); box-shadow:none; }
    .otherRow .barTok{ color: rgba(20,24,39,.55); }

    .forceRow{
      display:flex;
      gap: 10px;
      align-items:center;
      padding: 12px 14px;
      background: rgba(255,255,255,.70);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: 0 10px 28px rgba(20,24,39,.08);
    }
    .forceRow input{
      font-weight: 650;
    }

    /* Bottom controls */
    .controls{
      display:flex;
      align-items:center;
      justify-content:center;
      gap: 14px;
      padding: 14px 18px;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow2);
      backdrop-filter: blur(10px);
    }

    .bigBtn{
      display:flex;
      align-items:center;
      gap:10px;
      padding: 12px 16px;
      border-radius: 16px;
      font-size: 15px;
      font-weight: 900;
      border: 1px solid rgba(20,24,39,.12);
      background: rgba(255,255,255,.72);
      cursor:pointer;
      box-shadow: 0 12px 28px rgba(20,24,39,.10);
      transition: transform .12s ease, box-shadow .18s ease, border-color .18s ease;
      user-select:none;
    }
    .bigBtn:hover{ transform: translateY(-1px); box-shadow: none; border-color: rgba(var(--accent-rgb),.25); }
    .bigBtn.primary{
      background: var(--accent);
      border-color: rgba(255,255,255,.28);
      color:white;
    }
    .bigBtn svg{ width:18px; height:18px; }

    /* Wires overlay */
    .wires{
      position:absolute;
      inset:0;
      pointer-events:none;
    }

    .tokenOverlay{
      position:absolute;
      left:0; top:0;
      min-width: 260px;
      max-width: 360px;
      background: rgba(255,255,255,.96);
      border: 1px solid var(--border);
      border-radius: 14px;
      box-shadow: 0 18px 50px rgba(20,24,39,.16);
      padding: 12px;
      opacity: 0;
      transform: translateY(6px);
      transition: opacity .16s ease, transform .16s ease;
      pointer-events: auto;
      z-index: 4;
    }
    .tokenOverlay.visible{
      opacity: 1;
      transform: translateY(0);
    }
    .ovTitle{
      font-size: 12px;
      font-weight: 900;
      color: rgba(20,24,39,.85);
      margin-bottom: 6px;
    }
    .ovMeta{
      font-size: 11px;
      font-weight: 800;
      color: rgba(20,24,39,.6);
    }
    .ovParams{
      margin-top: 4px;
      font-size: 11px;
      font-weight: 700;
      color: rgba(20,24,39,.55);
      line-height: 1.35;
    }
    .ovBars{
      margin-top: 10px;
      display:flex;
      flex-direction:column;
      gap: 6px;
      max-height: 240px;
      overflow:auto;
      padding-right: 2px;
    }
    .ovRow{
      display:grid;
      grid-template-columns: 1fr 80px 50px;
      gap: 8px;
      align-items:center;
      padding: 6px 8px;
      border-radius: 10px;
      border: 1px solid rgba(20,24,39,.10);
      background: rgba(255,255,255,.78);
    }
    .ovRow.pickable{
      cursor: pointer;
      transition: transform .12s ease, box-shadow .18s ease, border-color .18s ease;
    }
    .ovRow.pickable:hover{
      transform: translateY(-1px);
      border-color: rgba(var(--accent-rgb),.35);
      box-shadow: none;
    }
    .ovRow.selected{
      border-color: rgba(var(--accent-rgb),.45);
      box-shadow: none;
    }
    .ovRow.cut{
      opacity: .55;
      filter: grayscale(.2);
    }
    .ovRow.invalid{
      opacity: .42;
      filter: grayscale(.65);
      cursor: not-allowed;
    }
    .ovTok{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 12px;
      font-weight: 800;
      overflow:hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      color: rgba(20,24,39,.75);
    }
    .ovTok.special{
      color: var(--specialText);
    }
    .ovBarWrap{
      position:relative;
      height: 10px;
      border-radius: 999px;
      background: rgba(20,24,39,.08);
      overflow:hidden;
    }
    .ovBar{
      position:absolute;
      inset:0;
      width: 0%;
      border-radius: 999px;
      background: rgba(var(--accent-rgb),.8);
      box-shadow: none;
    }
    .ovRow.cut .ovBar{
      background: rgba(20,24,39,.18);
      box-shadow: none;
    }
    .ovProb{
      text-align:right;
      font-variant-numeric: tabular-nums;
      font-size: 11px;
      font-weight: 900;
      color: rgba(20,24,39,.6);
    }

    .promptLibrary{
      position:absolute;
      inset:0;
      background: rgba(20,24,39,.28);
      display:flex;
      align-items:center;
      justify-content:center;
      opacity:0;
      pointer-events:none;
      transition: opacity .18s ease;
      z-index:5;
      padding: 24px;
    }
    .promptLibrary.open{
      opacity:1;
      pointer-events:auto;
    }
    .promptPanel{
      width: min(860px, 92vw);
      max-height: min(70vh, 640px);
      background: rgba(255,255,255,.98);
      border: 1px solid var(--border);
      border-radius: 18px;
      box-shadow: 0 24px 70px rgba(20,24,39,.22);
      padding: 16px;
      display:flex;
      flex-direction:column;
      gap: 12px;
    }
    .promptPanelHeader{
      display:flex;
      align-items:center;
      gap:10px;
    }
    .promptPanelHeader h4{
      margin:0;
      font-size: 14px;
      font-weight: 900;
      color: rgba(20,24,39,.85);
    }
    .promptGrid{
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 12px;
      overflow:auto;
      padding-right: 4px;
    }
    .promptCard{
      border: 1px solid rgba(20,24,39,.12);
      border-radius: 14px;
      background: rgba(255,255,255,.9);
      padding: 12px;
      box-shadow: 0 12px 26px rgba(20,24,39,.08);
      font-size: 13px;
      font-weight: 700;
      color: rgba(20,24,39,.8);
      cursor:pointer;
      transition: transform .12s ease, box-shadow .18s ease, border-color .18s ease;
      white-space: pre-wrap;
    }
    .promptCard:hover{
      transform: translateY(-2px);
      border-color: rgba(var(--accent-rgb),.35);
      box-shadow: none;
    }
    .promptPanelClose{
      margin-left:auto;
    }

    .statusLine{
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
    }
    .muted{
      color: var(--muted);
      font-size: 12px;
      font-weight: 650;
    }

    .hr{
      height:1px;
      background: rgba(20,24,39,.08);
      margin: 12px 0;
    }

    .hint{
      font-size: 12px;
      color: rgba(20,24,39,.55);
      font-weight: 650;
      line-height: 1.35;
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="sidebar">
      <div class="card">
        <h3>Model</h3>
        <div class="row">
          <input id="modelId" type="text" spellcheck="false" title="Hugging Face model ID (e.g. Qwen/Qwen2.5-0.5B-Instruct)" />
        </div>
        <div class="row" style="margin-top:10px;">
          <button id="loadModelBtn" class="btn primary" style="flex:1;" title="Load the model ID above into the server">Load model</button>
          <div id="modelStatusPill" class="pill warn">LOADING</div>
        </div>
        <div class="statusLine" style="margin-top:10px;">
          <div id="modelMeta" class="muted">—</div>
        </div>
        <div class="row" id="chatTemplateRow" style="margin-top:8px; display:none;">
          <label class="toggleRow" title="Enable the tokenizer chat template">
            <input id="useChatTemplate" type="checkbox" checked />
            Use chat template
          </label>
        </div>
      </div>

      <div class="card">
        <div class="cardHeader">
          <h3>Generation parameters</h3>
          <button class="cardToggle" data-target="decodingCard" title="Collapse decoding controls">
            <svg viewBox="0 0 24 24" fill="none"><path d="M7 10l5 5 5-5" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/></svg>
          </button>
        </div>

        <div class="cardBody" id="decodingCard">
          <div class="segmented" id="presetButtons">
          <button class="btn" data-preset="greedy" title="Always pick the highest-prob token">Greedy</button>
          <button class="btn active" data-preset="balanced" title="Balanced sampling defaults">Balanced</button>
          <button class="btn" data-preset="reliable" title="Lower randomness for consistency">Reliable</button>
          <button class="btn" data-preset="creative" title="Higher randomness for variety">Creative</button>
          <button class="btn" data-preset="custom" title="Use the sliders below">Custom</button>
          </div>

          <div class="hr"></div>

          <div class="col" id="customControls">
            <div>
              <label>Temperature</label>
              <div class="sliderRow">
          <input id="temperature" type="range" min="0" max="2" step="0.01" title="Randomness (lower = more deterministic)" />
                <div class="smallVal" id="temperatureVal"></div>
              </div>
            </div>

            <div>
              <label>Top‑p (nucleus)</label>
              <div class="sliderRow">
          <input id="topP" type="range" min="0" max="1" step="0.01" title="Nucleus threshold (keep cumulative probability)" />
                <div class="smallVal" id="topPVal"></div>
              </div>
            </div>

            <div>
              <label>Repetition penalty</label>
              <div class="sliderRow">
          <input id="repetitionPenalty" type="range" min="1" max="2" step="0.01" title="Penalize repeated tokens" />
                <div class="smallVal" id="repetitionPenaltyVal"></div>
              </div>
            </div>

            <div class="row">
              <div style="flex:1;">
                <label>Presence penalty</label>
              <input id="presencePenalty" type="number" step="0.1" min="-2" max="2" title="Penalize already-seen tokens" />
              </div>
              <div style="flex:1;">
                <label>Frequency penalty</label>
              <input id="frequencyPenalty" type="number" step="0.1" min="-2" max="2" title="Penalize repeated frequency" />
              </div>
            </div>

            <div class="row">
              <div style="flex:1;">
                <label>Seed (optional)</label>
              <input id="seed" type="number" step="1" placeholder="—" title="Fix randomness for repeatable results" />
              </div>
              <div style="flex:1;">
                <label>Stop sequences</label>
              <input id="stopSeq" type="text" placeholder="e.g. \n\n or ###" title="Stop when these sequences appear" />
              </div>
            </div>

            <div class="hint">
              Stop sequences are checked against the decoded assistant completion. Sampling always stops at the model EOS token.
            </div>
          </div>
        </div>
      </div>

      <div class="card">
        <div class="cardHeader">
          <h3>Constrained sampling</h3>
          <button class="cardToggle" data-target="constraintCard" title="Collapse constrained sampling controls">
            <svg viewBox="0 0 24 24" fill="none"><path d="M7 10l5 5 5-5" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/></svg>
          </button>
        </div>
        <div class="cardBody" id="constraintCard">
          <label class="toggleRow" title="Constrain next-token choices using a schema">
            <input id="constraintEnabled" type="checkbox" />
            Enable constrained sampling
          </label>
          <div class="row">
            <div style="flex:1;">
              <label>Output type</label>
              <select id="constraintType">
                <option value="multiple_choice">Multiple choice</option>
                <option value="regex">Regex</option>
                <option value="cfg">CFG</option>
                <option value="json_schema">JSON schema</option>
              </select>
            </div>
          </div>
          <label id="constraintSchemaLabel">Schema</label>
          <textarea id="constraintSchema" rows="8" spellcheck="false"></textarea>
          <div class="hint" id="constraintHint"></div>
        </div>
      </div>

      <div class="card">
        <div class="cardHeader">
          <h3>Step speed</h3>
          <button class="cardToggle" data-target="speedCard" title="Collapse speed controls">
            <svg viewBox="0 0 24 24" fill="none"><path d="M7 10l5 5 5-5" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/></svg>
          </button>
        </div>
        <div class="cardBody" id="speedCard">
          <label>Playback speed</label>
          <div class="sliderRow">
          <input id="stepSpeed" type="range" min="120" max="2000" step="10" title="Delay between auto-steps" />
            <div class="smallVal" id="stepSpeedVal"></div>
          </div>
          <div class="hint">Controls how fast the play button advances one token at a time.</div>
        </div>
      </div>

      <div class="card">
        <div class="cardHeader">
          <h3>Attribution</h3>
          <button class="cardToggle" data-target="attrCard" title="Collapse attribution controls">
            <svg viewBox="0 0 24 24" fill="none"><path d="M7 10l5 5 5-5" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/></svg>
          </button>
        </div>
        <div class="cardBody" id="attrCard">
          <label>Method</label>
          <select id="attrMethod">
            <option value="off">Off</option>
            <option value="attention">Attention</option>
            <option value="saliency">Saliency</option>
            <option value="input_x_gradient">Input × Gradient</option>
            <option value="integrated_gradients">Integrated Gradients</option>
          </select>
          <div class="hint">Hover a generated token or a candidate token to highlight input contributions.</div>
        </div>
      </div>
    </div>

    <div class="main">
      <div class="titleBar">
        <div>
          <h1>Next Token Visualization</h1>
          <div class="sub">Token-by-token sampling, nucleus filtering, temperature scaling, and penalties — in one view.</div>
        </div>
        <div class="statusLine">
        <div class="pill" id="serverPill" title="Backend connection status">Server</div>
          <div class="muted" id="serverMsg">—</div>
        </div>
      </div>

      <div class="viz" id="viz">
        <svg class="wires" id="wires"></svg>
        <div class="tokenOverlay" id="tokenOverlay"></div>
        <div class="promptLibrary" id="promptLibrary">
          <div class="promptPanel" role="dialog" aria-modal="true">
            <div class="promptPanelHeader">
              <h4>Example prompts</h4>
              <button class="btn ghost promptPanelClose" id="promptLibraryClose">Close</button>
            </div>
            <div class="promptGrid" id="promptLibraryGrid"></div>
          </div>
        </div>

        <div class="vizGrid">
          <div class="leftCol">
            <div class="branches" id="branches"></div>
            <div class="addBranchRow">
          <button id="newBranchBtn" class="btn ghost" style="flex:1;" title="Create a fresh input branch">＋ New input</button>
          <button id="clearBtn" class="btn danger" title="Clear this input and its completion">Clear</button>
            </div>
          </div>

          <div class="center">
            <div class="tokenStack" id="tokenStackCard">
              <div class="stackCol" id="tokenStack"></div>
            </div>
            <div class="llm" id="llmBox" title="Toggle LLM on/off">
              <span id="llmToggle">LLM</span>
            </div>
          </div>

          <div class="dist">
            <div class="distTop">
              <div class="kLabel">Top‑k</div>
              <input id="topK" type="number" min="1" max="50" step="1" title="How many tokens to show in the chart" />
              <div class="spacer"></div>
              <div class="title">Next token distribution</div>
            </div>

            <div class="legend">
              <span><span class="dot base"></span>Raw model</span>
              <span><span class="dot final"></span>Sampling distribution</span>
              <span class="muted" id="keptInfo"></span>
            </div>

            <div class="bars" id="bars"></div>

            <div class="forceRow">
          <input id="forceText" type="text" placeholder="Force token / text (appends immediately)" title="Appends immediately without sampling" />
          <button id="forceBtn" class="btn primary" title="Append this text immediately (no sampling)">Force</button>
            </div>
          </div>
        </div>
      </div>

      <div class="controls">
        <button id="playBtn" class="bigBtn primary" title="Auto-step through sampling">
          <svg viewBox="0 0 24 24" fill="none"><path d="M8 5v14l11-7-11-7Z" fill="currentColor"/></svg>
          <span id="playBtnLabel">Play</span>
        </button>
        <button id="stepBtn" class="bigBtn" title="Generate one token">
          <svg viewBox="0 0 24 24" fill="none"><path d="M16 6h2v12h-2V6Zm-10 0v12l9-6-9-6Z" fill="currentColor"/></svg>
          Step
        </button>
      </div>
    </div>
  </div>

<script>
(() => {
  const $ = (id) => document.getElementById(id);
  const int = (x) => parseInt(x, 10);

  const STORAGE_KEYS = {
    modelId: "llmDemo.modelId",
    params: "llmDemo.params",
    llmEnabled: "llmDemo.llmEnabled",
    decodingCollapsed: "llmDemo.decodingCollapsed",
    stepSpeedCollapsed: "llmDemo.stepSpeedCollapsed",
    attrCollapsed: "llmDemo.attrCollapsed",
    attrMethod: "llmDemo.attrMethod",
    constraintEnabled: "llmDemo.constraintEnabled",
    constraintType: "llmDemo.constraintType",
    constraintSchema: "llmDemo.constraintSchema",
    constraintCollapsed: "llmDemo.constraintCollapsed",
    topK: "llmDemo.topK",
    stepSpeedMs: "llmDemo.stepSpeedMs",
  };
  const DEFAULT_SYSTEM_PROMPT = "You are a helpful assistant.";
  const FORCE_TEXT_DEFAULT_PLACEHOLDER = "Force token / text (appends immediately)";
  const CONSTRAINT_TYPE_ORDER = ["multiple_choice", "regex", "cfg", "json_schema"];
  const CONSTRAINT_CONFIG = {
    multiple_choice: {
      label: "Multiple choice",
      placeholder: "One choice per line, or a JSON array.",
      hint: "Constrain output to one of these choices.",
      defaultSchema: "Yes\nNo\nMaybe"
    },
    regex: {
      label: "Regex",
      placeholder: "Regular expression pattern.",
      hint: "Constrain output to match this regex.",
      defaultSchema: "(yes|no)"
    },
    cfg: {
      label: "CFG",
      placeholder: "Grammar definition (Outlines CFG format).",
      hint: "Constrain output with a context-free grammar.",
      defaultSchema: "start: \"yes\" | \"no\""
    },
    json_schema: {
      label: "JSON schema",
      placeholder: "JSON Schema object.",
      hint: "Constrain output to valid JSON matching this schema.",
      defaultSchema: "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"answer\": { \"type\": \"string\" }\n  },\n  \"required\": [\"answer\"],\n  \"additionalProperties\": false\n}"
    }
  };

  function readStorage(key, fallback=null){
    try{
      const v = localStorage.getItem(key);
      return v === null ? fallback : v;
    }catch(e){
      return fallback;
    }
  }

  function writeStorage(key, value){
    try{
      localStorage.setItem(key, value);
    }catch(e){}
  }

  function readBool(key, fallback=false){
    const v = readStorage(key, null);
    if(v === null) return fallback;
    return v === "1";
  }

  function writeBool(key, value){
    writeStorage(key, value ? "1" : "0");
  }

  function readJson(key, fallback=null){
    const v = readStorage(key, null);
    if(v === null) return fallback;
    try{ return JSON.parse(v); }catch(e){ return fallback; }
  }

  const state = {
    model: null,
    modelStatus: null,
    topK: 10,
    stepSpeedMs: 650,
    playing: false,
    playTimer: null,
    defaultPreset: "balanced",
    defaultParams: {
      greedy: false,
      temperature: 0.7,
      top_p: 0.8,
      repetition_penalty: 1.05,
      presence_penalty: 0.0,
      frequency_penalty: 0.0,
      seed: null,
      stop_sequences: []
    },
    branches: [],
    activeBranchId: null,
    lastDist: null,
    serverOk: false,
    collapsePromptStack: false,
    llmEnabled: false,
    decodingCollapsedDefault: true,
    stepSpeedCollapsed: true,
    attrCollapsed: true,
    constraintCollapsed: true,
    constraintEnabled: false,
    constraintType: "multiple_choice",
    constraintSchema: CONSTRAINT_CONFIG.multiple_choice.defaultSchema,
    attrMethod: "off",
    attrReqId: 0,
    attrActiveKey: null,
    attrAppliedKey: null,
    chatTemplateEnabled: true,
  };

  const promptLibrary = [
    "The capital of France is",
    "In SQL, to select all columns you write",
    "Write a haiku about",
    "Sarah gave Anna her book because",
    "Continue the story: The door creaked open and",
    "Explain entropy to a 10-year-old in two sentences.",
    "Translate to Spanish, French, and Japanese: Good morning.",
    "Write Python code to compute Fibonacci numbers iteratively.",
    "Complete the sequence: 2, 3, 5, 7, 11,",
    "Give three pros and three cons of remote work.",
    "Summarize this in five words: Artificial intelligence is changing everything.",
    "Write a short dialogue between a pirate and an astronaut.",
  ];

  const presets = {
    greedy:   { greedy: true,  temperature: 1.0, top_p: 1.0, repetition_penalty: 1.0, presence_penalty: 0.0, frequency_penalty: 0.0 },
    reliable: { greedy: false, temperature: 0.25, top_p: 0.70, repetition_penalty: 1.10, presence_penalty: 0.0, frequency_penalty: 0.0 },
    balanced: { greedy: false, temperature: 0.70, top_p: 0.80, repetition_penalty: 1.05, presence_penalty: 0.0, frequency_penalty: 0.0 },
    creative: { greedy: false, temperature: 1.05, top_p: 0.95, repetition_penalty: 1.02, presence_penalty: 0.2, frequency_penalty: 0.1 }
  };

  function cloneParams(p){
    return {
      greedy: !!p.greedy,
      temperature: Number(p.temperature),
      top_p: Number(p.top_p),
      repetition_penalty: Number(p.repetition_penalty),
      presence_penalty: Number(p.presence_penalty || 0),
      frequency_penalty: Number(p.frequency_penalty || 0),
      seed: (p.seed === null || p.seed === undefined) ? null : Number(p.seed),
      stop_sequences: Array.isArray(p.stop_sequences) ? [...p.stop_sequences] : [],
    };
  }

  function uid(){
    return "b_" + Math.random().toString(16).slice(2) + "_" + Date.now().toString(16);
  }

  function fmtProb(p){
    if (p === null || p === undefined) return "—";
    const x = Math.max(0, Math.min(1, Number(p)));
    return x.toFixed(3);
  }

  function snapshotParams(){
    const params = getActiveParams();
    return {
      greedy: !!params.greedy,
      temperature: Number(params.temperature),
      top_p: Number(params.top_p),
      repetition_penalty: Number(params.repetition_penalty),
      presence_penalty: Number(params.presence_penalty),
      frequency_penalty: Number(params.frequency_penalty),
      seed: (params.seed === null || params.seed === undefined) ? null : Number(params.seed),
      stop_sequences: Array.isArray(params.stop_sequences) ? [...params.stop_sequences] : [],
      top_k: Number(state.topK),
    };
  }

  async function apiGet(path){
    const res = await fetch(path);
    if(!res.ok) throw new Error(await res.text());
    return res.json();
  }

  async function apiPost(path, data){
    const res = await fetch(path, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(data)
    });
    if(!res.ok) throw new Error(await res.text());
    return res.json();
  }

  function setServerStatus(ok, msg){
    state.serverOk = ok;
    $("serverPill").className = "pill " + (ok ? "ok" : "bad");
    $("serverPill").textContent = ok ? "Server OK" : "Server error";
    $("serverMsg").textContent = msg || "—";
  }

  function hasChatTemplate(){
    return !!(state.modelStatus && state.modelStatus.has_chat_template);
  }

  function isChatTemplateEnabled(){
    return hasChatTemplate() && !!state.chatTemplateEnabled;
  }

  function ensureSystemPrompt(b){
    if(!b) return DEFAULT_SYSTEM_PROMPT;
    if(typeof b.systemPrompt !== "string") b.systemPrompt = DEFAULT_SYSTEM_PROMPT;
    return b.systemPrompt;
  }

  function normalizeConstraintType(type){
    const t = String(type || "").toLowerCase();
    return CONSTRAINT_TYPE_ORDER.includes(t) ? t : "multiple_choice";
  }

  function getConstraintConfig(type=null){
    const key = normalizeConstraintType(type || state.constraintType);
    return CONSTRAINT_CONFIG[key] || CONSTRAINT_CONFIG.multiple_choice;
  }

  function isConstraintActive(){
    return !!state.constraintEnabled;
  }

  function getConstraintPayload(){
    return {
      enabled: !!state.constraintEnabled,
      type: normalizeConstraintType(state.constraintType),
      schema: String(state.constraintSchema || ""),
    };
  }

  function syncForceTextUi(){
    const input = $("forceText");
    const btn = $("forceBtn");
    if(!input || !btn) return;
    const disabled = isConstraintActive();
    input.disabled = disabled;
    btn.disabled = disabled;
    if(disabled){
      input.placeholder = "Force text disabled while constrained sampling is on";
      input.title = "Disabled while constrained sampling is enabled.";
      btn.title = "Disabled while constrained sampling is enabled.";
    }else{
      input.placeholder = FORCE_TEXT_DEFAULT_PLACEHOLDER;
      input.title = "Appends immediately without sampling";
      btn.title = "Append this text immediately (no sampling)";
    }
  }

  function syncConstraintUi(){
    state.constraintType = normalizeConstraintType(state.constraintType);
    const cfg = getConstraintConfig();
    const enabledEl = $("constraintEnabled");
    const typeEl = $("constraintType");
    const schemaEl = $("constraintSchema");
    const hintEl = $("constraintHint");
    const labelEl = $("constraintSchemaLabel");
    if(enabledEl) enabledEl.checked = !!state.constraintEnabled;
    if(typeEl) typeEl.value = state.constraintType;
    if(schemaEl){
      schemaEl.value = String(state.constraintSchema || "");
      schemaEl.placeholder = cfg.placeholder;
    }
    if(hintEl) hintEl.textContent = cfg.hint;
    if(labelEl) labelEl.textContent = `${cfg.label} schema`;
    syncForceTextUi();
  }

  function setConstraintEnabled(enabled){
    const next = !!enabled;
    if(state.constraintEnabled === next){
      syncConstraintUi();
      return;
    }
    state.constraintEnabled = next;
    writeBool(STORAGE_KEYS.constraintEnabled, state.constraintEnabled);
    syncConstraintUi();
    updatePreviewDebounced(true);
  }

  function setConstraintType(type){
    const nextType = normalizeConstraintType(type);
    const prevType = normalizeConstraintType(state.constraintType);
    if(prevType === nextType){
      syncConstraintUi();
      return;
    }
    state.constraintType = nextType;
    writeStorage(STORAGE_KEYS.constraintType, state.constraintType);
    const prevDefault = getConstraintConfig(prevType).defaultSchema;
    if(!state.constraintSchema || !state.constraintSchema.trim() || state.constraintSchema === prevDefault){
      state.constraintSchema = getConstraintConfig(nextType).defaultSchema;
      writeStorage(STORAGE_KEYS.constraintSchema, state.constraintSchema);
    }
    syncConstraintUi();
    updatePreviewDebounced(true);
  }

  function setConstraintSchema(schema){
    state.constraintSchema = String(schema ?? "");
    writeStorage(STORAGE_KEYS.constraintSchema, state.constraintSchema);
    updatePreviewDebounced(false);
  }

  function syncChatTemplateUi(){
    const row = $("chatTemplateRow");
    const cb = $("useChatTemplate");
    const available = hasChatTemplate();
    if(row) row.style.display = available ? "flex" : "none";
    if(cb){
      cb.checked = available && !!state.chatTemplateEnabled;
      cb.disabled = !available;
    }
  }

  function setChatTemplateEnabled(enabled){
    const available = hasChatTemplate();
    const next = available && !!enabled;
    if(state.chatTemplateEnabled === next){
      syncChatTemplateUi();
      return;
    }
    state.chatTemplateEnabled = next;
    syncChatTemplateUi();
    renderBranches();
    renderTokenStack();
    updatePreviewDebounced(true);
    if(state.modelStatus) setModelStatus(state.modelStatus);
  }

  function setModelStatus(status){
    const prevStatus = state.modelStatus || {};
    const prevModelId = prevStatus.model_id;
    const prevHasTemplate = !!prevStatus.has_chat_template;
    const prevEnabled = !!state.chatTemplateEnabled;

    state.modelStatus = status;
    const hasTemplate = !!status.has_chat_template;
    if(hasTemplate){
      if(!prevHasTemplate || status.model_id !== prevModelId || state.chatTemplateEnabled === undefined || state.chatTemplateEnabled === null){
        state.chatTemplateEnabled = true;
      }
    }else{
      state.chatTemplateEnabled = false;
    }
    syncChatTemplateUi();

    const pill = $("modelStatusPill");
    if(status.loading){
      pill.className = "pill warn";
      pill.textContent = "LOADING";
    }else if(status.ready){
      pill.className = "pill ok";
      pill.textContent = "READY";
    }else{
      pill.className = "pill bad";
      pill.textContent = "ERROR";
    }

    const meta = [];
    if(status.model_id) meta.push(status.model_id);
    if(status.device) meta.push("· " + status.device + " / " + status.dtype);
    if(status.has_chat_template){
      meta.push("· chat template " + (state.chatTemplateEnabled ? "on" : "off"));
    }
    if(status.eos_token_id !== null && status.eos_token_id !== undefined) meta.push("· eos=" + status.eos_token_id);
    $("modelMeta").textContent = meta.join(" ");

    if((prevHasTemplate !== hasTemplate) || (prevEnabled !== state.chatTemplateEnabled)){
      renderBranches();
      renderTokenStack();
    }
  }

  function setLlmEnabled(enabled){
    state.llmEnabled = !!enabled;
    writeBool(STORAGE_KEYS.llmEnabled, state.llmEnabled);
    const llm = $("llmBox");
    const dist = document.querySelector(".dist");
    llm.classList.toggle("off", !state.llmEnabled);
    if(dist) dist.classList.toggle("off", !state.llmEnabled);
    if(!state.llmEnabled){
      stopPlayback();
      clearAttribution();
      renderDistribution(null);
      setServerStatus(true, "LLM is off");
    }else{
      updatePreviewDebounced(true);
    }
  }

  const chevronDown = '<svg viewBox="0 0 24 24" fill="none"><path d="M7 10l5 5 5-5" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/></svg>';
  const chevronUp = '<svg viewBox="0 0 24 24" fill="none"><path d="M7 14l5-5 5 5" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/></svg>';

  function setCardCollapsed(card, collapsed, toggleBtn){
    if(!card) return;
    card.classList.toggle("collapsed", !!collapsed);
    if(toggleBtn){
      toggleBtn.title = collapsed ? "Expand" : "Collapse";
      toggleBtn.innerHTML = collapsed ? chevronUp : chevronDown;
    }
  }

  function syncDecodingCollapse(){
    const b = getActiveBranch();
    const card = $("decodingCard") ? $("decodingCard").closest(".card") : null;
    const toggleBtn = document.querySelector('.cardToggle[data-target="decodingCard"]');
    const collapsed = b ? !!b.decodingCollapsed : state.decodingCollapsedDefault;
    setCardCollapsed(card, collapsed, toggleBtn);
  }

  function syncSpeedCollapse(){
    const card = $("speedCard") ? $("speedCard").closest(".card") : null;
    const toggleBtn = document.querySelector('.cardToggle[data-target="speedCard"]');
    setCardCollapsed(card, !!state.stepSpeedCollapsed, toggleBtn);
  }

  function syncConstraintCollapse(){
    const card = $("constraintCard") ? $("constraintCard").closest(".card") : null;
    const toggleBtn = document.querySelector('.cardToggle[data-target="constraintCard"]');
    setCardCollapsed(card, !!state.constraintCollapsed, toggleBtn);
  }

  function syncAttrCollapse(){
    const card = $("attrCard") ? $("attrCard").closest(".card") : null;
    const toggleBtn = document.querySelector('.cardToggle[data-target="attrCard"]');
    setCardCollapsed(card, !!state.attrCollapsed, toggleBtn);
  }

  function openPromptLibrary(){
    const overlay = $("promptLibrary");
    const grid = $("promptLibraryGrid");
    grid.innerHTML = "";
    promptLibrary.forEach(text => {
      const card = document.createElement("div");
      card.className = "promptCard";
      card.textContent = text;
      card.addEventListener("click", () => {
        applyPromptExample(text);
        closePromptLibrary();
      });
      grid.appendChild(card);
    });
    overlay.classList.add("open");
  }

  function closePromptLibrary(){
    $("promptLibrary").classList.remove("open");
  }

  function applyPromptExample(text){
    const b = getActiveBranch();
    if(!b) return;
    stopPlayback();
    b.prompt = text;
    b.completionIds = [];
    b.promptTokens = [];
    b.completionTokens = [];
    b.done = false;
    b.resetRng = true;
    renderBranches();
    renderTokenStack();
    renderDistribution(null);
    updatePreviewDebounced(true);
  }

  function loadStoredSettings(){
    const storedTopK = readStorage(STORAGE_KEYS.topK, null);
    if(storedTopK !== null && storedTopK !== undefined){
      const k = Number(storedTopK);
      if(!Number.isNaN(k)) state.topK = Math.max(1, Math.min(50, k));
    }
    const storedSpeed = readStorage(STORAGE_KEYS.stepSpeedMs, null);
    if(storedSpeed !== null && storedSpeed !== undefined){
      const s = Number(storedSpeed);
      if(!Number.isNaN(s)) state.stepSpeedMs = Math.max(80, s);
    }

    const saved = readJson(STORAGE_KEYS.params, null);
    if(saved && saved.params){
      const merged = { ...state.defaultParams, ...saved.params };
      merged.stop_sequences = Array.isArray(saved.params.stop_sequences) ? [...saved.params.stop_sequences] : [];
      state.defaultParams = cloneParams(merged);
    }
    if(saved && saved.preset){
      state.defaultPreset = saved.preset;
    }
    if(state.defaultPreset === "greedy"){
      state.defaultParams.greedy = true;
    }else if(state.defaultParams.greedy && state.defaultPreset !== "greedy"){
      state.defaultParams.greedy = false;
    }

    state.llmEnabled = readBool(STORAGE_KEYS.llmEnabled, false);
    state.decodingCollapsedDefault = readBool(STORAGE_KEYS.decodingCollapsed, true);
    state.stepSpeedCollapsed = readBool(STORAGE_KEYS.stepSpeedCollapsed, true);
    state.attrCollapsed = readBool(STORAGE_KEYS.attrCollapsed, true);
    state.constraintCollapsed = readBool(STORAGE_KEYS.constraintCollapsed, true);
    state.constraintEnabled = readBool(STORAGE_KEYS.constraintEnabled, false);
    const storedConstraintType = readStorage(STORAGE_KEYS.constraintType, null);
    if(storedConstraintType){
      state.constraintType = normalizeConstraintType(storedConstraintType);
    }else{
      state.constraintType = "multiple_choice";
    }
    const storedConstraintSchema = readStorage(STORAGE_KEYS.constraintSchema, null);
    if(storedConstraintSchema !== null && storedConstraintSchema !== undefined){
      state.constraintSchema = String(storedConstraintSchema);
    }
    if(!state.constraintSchema || !state.constraintSchema.trim()){
      state.constraintSchema = getConstraintConfig(state.constraintType).defaultSchema;
    }

    const storedAttr = readStorage(STORAGE_KEYS.attrMethod, null);
    if(storedAttr){
      const m = String(storedAttr).toLowerCase();
      if(["off","attention","saliency","input_x_gradient","integrated_gradients"].includes(m)){
        state.attrMethod = m;
      }
    }
  }

  async function pollModelReady(){
    for(;;){
      let st;
      try{
        st = await apiGet("/api/model/status");
        setServerStatus(true, "");
      }catch(e){
        setServerStatus(false, String(e).slice(0,160));
        await new Promise(r => setTimeout(r, 700));
        continue;
      }
      setModelStatus(st);
      if(st.ready) return st;

      // If loading stopped and the model isn't ready, surface the error instead of looping forever.
      if(!st.loading && !st.ready){
        const errMsg = (st.error || "Model failed to load.").split("")[0];
        throw new Error(errMsg);
      }

      const msg = (st.error || "Loading model…").split("")[0];
      setServerStatus(true, msg);
      await new Promise(r => setTimeout(r, 700));
    }
  }

  function getActiveBranch(){
    return state.branches.find(b => b.id === state.activeBranchId) || null;
  }

  function getActiveParams(){
    const b = getActiveBranch();
    return b ? b.params : state.defaultParams;
  }

  function getActivePreset(){
    const b = getActiveBranch();
    return b ? b.preset : state.defaultPreset;
  }

  function stopPlayback(){
    state.playing = false;
    if(state.playTimer) clearTimeout(state.playTimer);
    state.playTimer = null;
    $("playBtnLabel").textContent = "Play";
    $("playBtn").querySelector("svg").innerHTML = '<path d="M8 5v14l11-7-11-7Z" fill="currentColor"/>';
  }

  function deleteLastCompletionToken(){
    const b = getActiveBranch();
    if(!b || !b.completionIds || b.completionIds.length === 0) return;
    stopPlayback();
    b.completionIds.pop();
    b.completionTokens = (b.completionTokens || []).slice(0, b.completionIds.length);
    b.done = false;
    b.resetRng = true;
    $("tokenOverlay").classList.remove("visible");
    renderBranches();
    renderTokenStack();
    updatePreviewDebounced(true);
  }

  function replaceCompletionAtIndex(index, tokenObj, sourceMeta){
    const b = getActiveBranch();
    if(!b || index === null || index === undefined) return;
    if(tokenObj && tokenObj.valid === false){
      setServerStatus(true, "Token is invalid for the active constraint.");
      return;
    }
    const idx = Number(index);
    if(Number.isNaN(idx) || idx < 0) return;
    stopPlayback();

    const rawId = (tokenObj && tokenObj.id !== undefined) ? tokenObj.id : tokenObj;
    const tokenId = Number(rawId);
    if(Number.isNaN(tokenId)) return;
    const keptIds = (b.completionIds || []).slice(0, idx);
    keptIds.push(int(tokenId));
    b.completionIds = keptIds;

    const keptTokens = (b.completionTokens || []).slice(0, idx);
    const baseMeta = sourceMeta?.meta || sourceMeta || {};
    const paramsSnapshot = baseMeta.params || snapshotParams();
    const replacementMeta = {
      dist: baseMeta.dist || null,
      selected_id: int(tokenId),
      forced: true,
      forced_by: "overlay",
      greedy: !!(baseMeta.greedy ?? paramsSnapshot.greedy),
      params: paramsSnapshot,
      top_k: baseMeta.top_k ?? paramsSnapshot.top_k ?? state.topK,
      completion_index: idx,
    };
    const replacement = {
      ...(tokenObj || {}),
      id: int(tokenId),
      display: tokenObj.display || String(tokenId),
      text: tokenObj.text || tokenObj.display || String(tokenId),
      special: !!tokenObj.special,
      _new: true,
      meta: replacementMeta,
    };
    keptTokens.push(replacement);
    b.completionTokens = keptTokens;
    b.done = false;
    b.resetRng = true;
    $("tokenOverlay").classList.remove("visible");
    renderBranches();
    renderTokenStack();
    updatePreviewDebounced(true);
  }

  function applyPreset(name){
    const b = getActiveBranch();
    if(!b) return;
    b.preset = name;
    if(name !== "custom"){
      const p = presets[name] || presets.balanced;
      b.params = {
        ...b.params,
        greedy: p.greedy,
        temperature: p.temperature,
        top_p: p.top_p,
        repetition_penalty: p.repetition_penalty,
        presence_penalty: p.presence_penalty,
        frequency_penalty: p.frequency_penalty,
      };
    }
    state.defaultParams = cloneParams(b.params);
    state.defaultPreset = b.preset;
    writeStorage(STORAGE_KEYS.params, JSON.stringify({ params: state.defaultParams, preset: state.defaultPreset }));
    syncControlsFromState();
    updatePreviewDebounced(true);
  }

  function markCustomPreset(){
    // If the user tweaks any decoding control, switch to "custom" unless greedy is enabled.
    const b = getActiveBranch();
    if(!b) return;
    if(b.params.greedy) return;
    if(b.preset === "custom") return;
    b.preset = "custom";
    state.defaultPreset = b.preset;
    $("presetButtons").querySelectorAll(".btn").forEach(btn => btn.classList.toggle("active", btn.dataset.preset === "custom"));
  }

  function syncControlsFromState(){
    const b = getActiveBranch();
    const params = b ? b.params : state.defaultParams;
    const preset = b ? b.preset : state.defaultPreset;

    $("temperature").value = params.temperature;
    $("topP").value = params.top_p;
    $("repetitionPenalty").value = params.repetition_penalty;
    $("presencePenalty").value = params.presence_penalty;
    $("frequencyPenalty").value = params.frequency_penalty;
    $("temperatureVal").textContent = Number(params.temperature).toFixed(2);
    $("topPVal").textContent = Number(params.top_p).toFixed(2);
    $("repetitionPenaltyVal").textContent = Number(params.repetition_penalty).toFixed(2);

    $("topK").value = state.topK;
    $("stepSpeed").value = state.stepSpeedMs;
    $("stepSpeedVal").textContent = state.stepSpeedMs + " ms";
    if($("attrMethod")) $("attrMethod").value = state.attrMethod;
    syncConstraintUi();

    // Seed
    $("seed").value = (params.seed === null || params.seed === undefined) ? "" : String(params.seed);

    // Stop sequences: for UX we keep a single text input. Split by |
    const s = (params.stop_sequences || []).join(" | ");
    $("stopSeq").value = s;

    // Preset buttons
    $("presetButtons").querySelectorAll(".btn").forEach(btn => btn.classList.toggle("active", btn.dataset.preset === preset));

    // Disable controls when greedy
    const disabled = !!params.greedy;
    ["temperature","topP"].forEach(id => $(id).disabled = disabled);
  }

  function readParamsFromControls(){
    const b = getActiveBranch();
    if(!b) return;
    b.params.temperature = Number($("temperature").value);
    b.params.top_p = Number($("topP").value);
    b.params.repetition_penalty = Number($("repetitionPenalty").value);
    b.params.presence_penalty = Number($("presencePenalty").value || 0);
    b.params.frequency_penalty = Number($("frequencyPenalty").value || 0);

    const seedStr = ($("seed").value || "").trim();
    b.params.seed = seedStr === "" ? null : Number(seedStr);

    const stopRaw = ($("stopSeq").value || "").trim();
    b.params.stop_sequences = stopRaw === "" ? [] : stopRaw.split("|").map(s => s.trim()).filter(Boolean);

    state.defaultParams = cloneParams(b.params);
    state.defaultPreset = b.preset;
    writeStorage(STORAGE_KEYS.params, JSON.stringify({ params: state.defaultParams, preset: state.defaultPreset }));

    // Greedy is set only through preset button
  }

  function renderBranches(){
    const wrap = $("branches");
    const prevScrollTop = wrap.scrollTop;
    let focusInfo = null;
    const activeEl = document.activeElement;
    if(activeEl && activeEl.tagName === "TEXTAREA"){
      const branchEl = activeEl.closest(".branch");
      if(branchEl && branchEl.dataset.branchId === state.activeBranchId){
        focusInfo = {
          branchId: branchEl.dataset.branchId,
          role: activeEl.dataset.role || "prompt",
          selectionStart: activeEl.selectionStart,
          selectionEnd: activeEl.selectionEnd,
          scrollTop: activeEl.scrollTop
        };
      }
    }
    wrap.innerHTML = "";

    state.branches.forEach((b, idx) => {
      const div = document.createElement("div");
      div.className = "branch " + (b.id === state.activeBranchId ? "active" : "inactive");
      div.dataset.branchId = b.id;

      const header = document.createElement("div");
      header.className = "branchHeader";

      const title = document.createElement("div");
      title.className = "branchTitle";
      title.textContent = "Input " + (idx + 1);

      const meta = document.createElement("div");
      meta.className = "branchMeta";
      const nTok = (b.promptTokens?.length || 0) + (b.completionTokens?.length || 0);
      meta.textContent = "· " + nTok + " tokens";

      header.appendChild(title);
      header.appendChild(meta);

      if(b.id === state.activeBranchId){
        const book = document.createElement("button");
        book.className = "iconBtn";
        book.title = "Example prompts · replace this input";
        book.innerHTML = '<svg viewBox="0 0 24 24" fill="none"><path d="M5 4.5c0-.83.67-1.5 1.5-1.5h9c1.93 0 3.5 1.57 3.5 3.5v12a2 2 0 0 1-2 2H7a2 2 0 0 0-2 2V4.5Z" stroke="currentColor" stroke-width="1.6"/><path d="M5 19.5c0-1.1.9-2 2-2h11" stroke="currentColor" stroke-width="1.6"/></svg>';
        book.addEventListener("click", (e) => {
          e.stopPropagation();
          openPromptLibrary();
        });
        header.appendChild(book);

        const fork = document.createElement("button");
        fork.className = "btn forkBtn";
        fork.title = "Fork this input · duplicate and branch";
        fork.innerHTML = '<svg viewBox="0 0 24 24" fill="none"><line x1="6" y1="3" x2="6" y2="15" stroke="currentColor" stroke-width="1.9" stroke-linecap="round"/><circle cx="18" cy="6" r="3" stroke="currentColor" stroke-width="1.9"/><circle cx="6" cy="18" r="3" stroke="currentColor" stroke-width="1.9"/><path d="M18 9a9 9 0 0 1-9 9" stroke="currentColor" stroke-width="1.9" stroke-linecap="round"/></svg>';
        fork.addEventListener("click", (e) => {
          e.stopPropagation();
          forkBranch(b.id);
        });
        header.appendChild(fork);
      }

      div.appendChild(header);

      const showSystem = isChatTemplateEnabled();
      if(showSystem){
        const sysBlock = document.createElement("div");
        sysBlock.className = "inputBlock";
        const sysLabel = document.createElement("label");
        sysLabel.textContent = "System message";
        const sysTa = document.createElement("textarea");
        sysTa.className = "systemPrompt";
        sysTa.dataset.role = "system";
        sysTa.placeholder = "System message…";
        sysTa.value = ensureSystemPrompt(b);
        sysTa.addEventListener("focus", () => selectBranch(b.id));
        sysTa.addEventListener("click", () => selectBranch(b.id));
        sysTa.addEventListener("input", () => {
          b.systemPrompt = sysTa.value;
          // Editing system message resets completion.
          b.completionIds = [];
          b.completionTokens = [];
          b.done = false;
          b.resetRng = true;
          updateBranchTokensSoon(b.id);
        });
        sysBlock.appendChild(sysLabel);
        sysBlock.appendChild(sysTa);
        div.appendChild(sysBlock);
      }

      const promptBlock = document.createElement("div");
      promptBlock.className = "inputBlock";
      if(showSystem){
        const promptLabel = document.createElement("label");
        promptLabel.textContent = "User message";
        promptBlock.appendChild(promptLabel);
      }

      const ta = document.createElement("textarea");
      ta.dataset.role = "prompt";
      ta.placeholder = "Enter a prompt…";
      ta.value = b.prompt;
      ta.addEventListener("focus", () => selectBranch(b.id));
      ta.addEventListener("click", () => selectBranch(b.id));
      ta.addEventListener("input", () => {
        b.prompt = ta.value;
        // Editing prompt resets completion.
        b.completionIds = [];
        b.completionTokens = [];
        b.done = false;
        b.resetRng = true;
        updateBranchTokensSoon(b.id);
      });
      promptBlock.appendChild(ta);
      div.appendChild(promptBlock);

      const tokWrap = document.createElement("div");
      tokWrap.className = "tokenWrap";
      const promptToks = b.promptTokens || [];
      const genToks = b.completionTokens || [];

      promptToks.forEach((t, i) => {
        const s = document.createElement("span");
        s.className = "tok" + (t.special ? " special" : "");
        s.textContent = t.display;
        s.dataset.tokenIndex = String(i);
        tokWrap.appendChild(s);
      });

      if(genToks.length){
        const sep = document.createElement("span");
        sep.className = "dividerTok";
        sep.textContent = "⇢";
        tokWrap.appendChild(sep);
      }

      genToks.forEach((t, i) => {
        const s = document.createElement("span");
        const isLast = i === genToks.length - 1;
        s.className = "tok gen" + (t.special ? " special" : "") + (isLast ? " delete" : "");
        s.textContent = t.display;
        s.dataset.tokenIndex = String(promptToks.length + i);
        attachTokenOverlay(s, t, i);
        if(isLast){
          s.title = "Click to remove last completion token";
          s.addEventListener("click", (e) => {
            e.stopPropagation();
            deleteLastCompletionToken();
          });
        }
        tokWrap.appendChild(s);
      });

      div.appendChild(tokWrap);

      div.addEventListener("click", () => selectBranch(b.id));
      wrap.appendChild(div);
    });

    wrap.scrollTop = prevScrollTop;
    if(focusInfo){
      const sel = `.branch[data-branch-id="${focusInfo.branchId}"] textarea[data-role="${focusInfo.role}"]`;
      const ta = wrap.querySelector(sel) || wrap.querySelector(`.branch[data-branch-id="${focusInfo.branchId}"] textarea`);
      if(ta){
        ta.focus({ preventScroll: true });
        try{
          ta.setSelectionRange(focusInfo.selectionStart, focusInfo.selectionEnd);
        }catch(e){}
        ta.scrollTop = focusInfo.scrollTop;
      }
    }

    // After rendering, wires need update
    requestAnimationFrame(drawWires);
  }

  function renderTokenStack(){
    const b = getActiveBranch();
    const stack = $("tokenStack");
    stack.innerHTML = "";
    if(!b){
      requestAnimationFrame(drawWires);
      return;
    }
    const promptTokens = b.promptTokens || [];
    const completionTokens = b.completionTokens || [];
    const hasPrompt = promptTokens.length > 0;
    const lastCompletionIndex = completionTokens.length - 1;
    const makeTokenEl = (token, { gen=false, deletable=false, toggle=false, onToggle=null, completionIndex=null } = {}) => {
      const t = (token && token.display !== undefined) ? token : { display: String(token) };
      const special = !!t.special;
      const div = document.createElement("div");
      div.className = "stackTok" + (gen ? " gen" : "") + (special ? " special" : "") + (deletable ? " delete" : "") + (toggle ? " toggle" : "");
      div.textContent = t.display;
      if(deletable){
        div.title = "Click to remove last completion token";
        div.addEventListener("click", (e) => {
          e.stopPropagation();
          deleteLastCompletionToken();
        });
      }
      if(toggle && onToggle){
        div.title = "Click to collapse prompt tokens";
        div.addEventListener("click", (e) => {
          e.stopPropagation();
          onToggle();
        });
      }
      if(gen && token && token.meta){
        attachTokenOverlay(div, token, token.meta.completion_index);
      }
      if(gen && token && token.id !== undefined && completionIndex !== null && completionIndex !== undefined){
        div.addEventListener("mouseenter", () => queueAttribution(completionIndex, token.id));
        div.addEventListener("mouseleave", scheduleClearAttribution);
      }
      return div;
    };

    if(state.collapsePromptStack && hasPrompt){
      const summary = document.createElement("div");
      summary.className = "stackTok summary toggle";
      summary.textContent = `Prompt ×${promptTokens.length}`;
      summary.title = "Click to expand prompt tokens";
      summary.addEventListener("click", (e) => {
        e.stopPropagation();
        state.collapsePromptStack = false;
        renderTokenStack();
      });
      stack.appendChild(summary);
    }else{
      const tokens = [...promptTokens, ...completionTokens];
      tokens.forEach((t, i) => {
        const isGen = i >= promptTokens.length;
        const canToggle = hasPrompt && i === 0;
        const isLastCompletion = isGen && (i - promptTokens.length === lastCompletionIndex);
        if(t && t.meta && t.meta.completion_index === undefined){
          t.meta.completion_index = i - promptTokens.length;
        }
        const div = makeTokenEl(t, {
          gen: isGen,
          deletable: isLastCompletion,
          toggle: canToggle,
          completionIndex: isGen ? (i - promptTokens.length) : null,
          onToggle: () => {
            state.collapsePromptStack = true;
            renderTokenStack();
          }
        });
        if(isLastCompletion){
          div.title = "Click to remove last completion token";
        }
        stack.appendChild(div);
      });
    }

    // Always render completion tokens (green) beneath the summary when collapsed.
    if(state.collapsePromptStack && completionTokens.length){
      completionTokens.forEach((t, i) => {
        if(t && t.meta && t.meta.completion_index === undefined){
          t.meta.completion_index = i;
        }
        const isLastCompletion = i === lastCompletionIndex;
        const div = makeTokenEl(t, {
          gen: true,
          deletable: isLastCompletion,
          completionIndex: i
        });
        stack.appendChild(div);
      });
    }
    requestAnimationFrame(drawWires);
  }

  function renderDistribution(dist, highlightTokenId=null){
    state.lastDist = dist;
    const bars = $("bars");
    bars.innerHTML = "";

    if(!dist){
      bars.innerHTML = '<div class="muted" style="padding:10px 4px;">No distribution yet.</div>';
      $("keptInfo").textContent = "";
      requestAnimationFrame(drawWires);
      return;
    }

    $("keptInfo").textContent = dist.kept_token_count ? ("· nucleus keeps " + dist.kept_token_count + " tokens") : "";

    const maxP = Math.max(...dist.tokens.map(t => t.p_final || 0), dist.other_p_final || 0, 1e-9);
    const greedyActive = !!getActiveParams().greedy;
    let greedyTopId = null;
    if(greedyActive && dist.tokens.length){
      let best = dist.tokens[0];
      let bestP = (best.p_final ?? best.p_base ?? 0);
      dist.tokens.forEach(t => {
        const p = (t.p_final ?? t.p_base ?? 0);
        if(p > bestP){
          best = t;
          bestP = p;
        }
      });
      greedyTopId = best ? best.id : null;
    }

    dist.tokens.forEach(t => {
      const isInvalid = (t.valid === false);
      const row = document.createElement("div");
      row.className = "barRow" + (highlightTokenId === t.id ? " selected" : "") + (greedyTopId === t.id ? " greedyPick" : "");
      row.dataset.tokenId = t.id;
      if(t.kept === false) row.classList.add("cut");
      if(isInvalid) row.classList.add("invalid");

      const tok = document.createElement("div");
      tok.className = "barTok";
      tok.textContent = t.display;
      if(t.special) tok.classList.add("special");

      const wrap = document.createElement("div");
      wrap.className = "barWrap";

      const base = document.createElement("div");
      base.className = "barBase";
      const final = document.createElement("div");
      final.className = "barFinal";

      // Scale bar widths relative to 1.0 (probability), not maxP, so it's interpretable.
      base.style.width = (Math.max(0, Math.min(1, t.p_base)) * 100).toFixed(2) + "%";
      final.style.width = (Math.max(0, Math.min(1, t.p_final)) * 100).toFixed(2) + "%";

      wrap.appendChild(base);
      wrap.appendChild(final);

      const prob = document.createElement("div");
      prob.className = "barProb";
      prob.textContent = fmtProb(t.p_final);

      row.appendChild(tok);
      row.appendChild(wrap);
      row.appendChild(prob);

      if(isInvalid){
        row.title = "Invalid under active constraint";
      }else{
        row.addEventListener("mouseenter", () => {
          const b = getActiveBranch();
          const nextIdx = b ? (b.completionIds || []).length : 0;
          queueAttribution(nextIdx, t.id);
        });
        row.addEventListener("mouseleave", scheduleClearAttribution);
        row.addEventListener("click", () => {
          forceToken(t.id);
        });
      }

      bars.appendChild(row);
    });

    // Other mass row
    const other = document.createElement("div");
    other.className = "barRow otherRow";
    other.innerHTML = `
      <div class="barTok">Other</div>
      <div class="barWrap">
        <div class="barBase"></div>
        <div class="barFinal"></div>
      </div>
      <div class="barProb">${fmtProb(dist.other_p_final)}</div>
    `;
    const otherBase = other.querySelector(".barBase");
    const otherFinal = other.querySelector(".barFinal");
    otherBase.style.width = (Math.max(0, Math.min(1, dist.other_p_base)) * 100).toFixed(2) + "%";
    otherFinal.style.width = (Math.max(0, Math.min(1, dist.other_p_final)) * 100).toFixed(2) + "%";
    bars.appendChild(other);
    requestAnimationFrame(drawWires);
  }

  let attrHoverTimer = null;
  let attrClearTimer = null;

  function setAttrMethod(method){
    const m = String(method || "off").toLowerCase();
    state.attrMethod = ["off","attention","saliency","input_x_gradient","integrated_gradients"].includes(m) ? m : "off";
    writeStorage(STORAGE_KEYS.attrMethod, state.attrMethod);
    clearAttribution();
  }

  function clearAttribution(){
    if(attrHoverTimer) clearTimeout(attrHoverTimer);
    if(attrClearTimer) clearTimeout(attrClearTimer);
    attrHoverTimer = null;
    attrClearTimer = null;
    state.attrActiveKey = null;
    state.attrAppliedKey = null;
    state.attrReqId += 1;
    const activeBranchEl = document.querySelector(".branch.active");
    if(!activeBranchEl) return;
    activeBranchEl.querySelectorAll(".tok.attrHeat").forEach(el => {
      el.classList.remove("attrHeat");
      el.style.removeProperty("--attr-alpha");
    });
  }

  function scheduleClearAttribution(){
    if(attrClearTimer) clearTimeout(attrClearTimer);
    attrClearTimer = setTimeout(() => {
      clearAttribution();
    }, 120);
  }

  function applyAttributionHeat(values){
    const activeBranchEl = document.querySelector(".branch.active");
    if(!activeBranchEl) return;
    const toks = activeBranchEl.querySelectorAll(".tok");
    let maxAbs = 0;
    (values || []).forEach(v => {
      const a = Math.abs(Number(v) || 0);
      if(a > maxAbs) maxAbs = a;
    });
    toks.forEach(el => {
      const idx = Number(el.dataset.tokenIndex);
      if(Number.isNaN(idx) || idx < 0 || idx >= (values || []).length || maxAbs <= 0){
        el.classList.remove("attrHeat");
        el.style.removeProperty("--attr-alpha");
        return;
      }
      const v = Math.abs(Number(values[idx]) || 0);
      const alpha = 0.08 + (0.65 - 0.08) * (v / maxAbs);
      el.style.setProperty("--attr-alpha", alpha.toFixed(3));
      el.classList.add("attrHeat");
    });
  }

  function queueAttribution(targetIndex, tokenId){
    if(state.attrMethod === "off" || !state.llmEnabled) return;
    const b = getActiveBranch();
    if(!b) return;
    if(attrClearTimer) clearTimeout(attrClearTimer);
    const idx = Number(targetIndex);
    if(Number.isNaN(idx)) return;
    const key = `${b.id}:${idx}:${tokenId}:${state.attrMethod}`;
    if(state.attrAppliedKey === key) return;
    state.attrActiveKey = key;
    if(attrHoverTimer) clearTimeout(attrHoverTimer);
    attrHoverTimer = setTimeout(() => {
      fetchAttribution(idx, tokenId, key);
    }, 80);
  }

  async function fetchAttribution(targetIndex, tokenId, key){
    const b = getActiveBranch();
    if(!b) return;
    const reqId = ++state.attrReqId;
    try{
      const res = await apiPost("/api/attribution", {
        branch_id: b.id,
        prompt: b.prompt,
        system_prompt: ensureSystemPrompt(b),
        use_chat_template: isChatTemplateEnabled(),
        completion_ids: b.completionIds || [],
        target_index: targetIndex,
        target_token_id: tokenId,
        method: state.attrMethod
      });
      if(res && res.ok === false){
        clearAttribution();
        return;
      }
      if(reqId !== state.attrReqId || state.attrActiveKey !== key) return;
      applyAttributionHeat(res.attributions || []);
      state.attrAppliedKey = key;
    }catch(e){
      if(reqId === state.attrReqId){
        clearAttribution();
      }
    }
  }

  let overlayHideTimer = null;

  function scheduleHideOverlay(){
    if(overlayHideTimer) clearTimeout(overlayHideTimer);
    overlayHideTimer = setTimeout(() => {
      $("tokenOverlay").classList.remove("visible");
    }, 120);
  }

  function attachTokenOverlay(el, tokenObj, completionIndex){
    if(!tokenObj || !tokenObj.meta || !tokenObj.meta.dist) return;
    el.addEventListener("mouseenter", () => showTokenOverlay(el, tokenObj, completionIndex));
    el.addEventListener("mouseleave", scheduleHideOverlay);
  }

  function showTokenOverlay(el, tokenObj, completionIndex){
    const meta = tokenObj.meta;
    if(!meta || !meta.dist) return;
    if(overlayHideTimer) clearTimeout(overlayHideTimer);

    const overlay = $("tokenOverlay");
    overlay.innerHTML = "";

    const title = document.createElement("div");
    title.className = "ovTitle";
    title.textContent = `Token: ${tokenObj.display}`;
    overlay.appendChild(title);

    const method = document.createElement("div");
    method.className = "ovMeta";
    const forcedBy = meta.forced_by ? `Forced (${meta.forced_by})` : null;
    const methodLabel = forcedBy || (meta.greedy ? "Greedy" : "Sampled");
    method.textContent = `Method: ${methodLabel}`;
    overlay.appendChild(method);

    const p = meta.params || {};
    const parts = [
      `top_k ${meta.top_k ?? p.top_k ?? state.topK}`,
      `top_p ${Number(p.top_p ?? 0).toFixed(2)}`,
      `temp ${Number(p.temperature ?? 0).toFixed(2)}`,
      `rep ${Number(p.repetition_penalty ?? 1).toFixed(2)}`,
      `pres ${Number(p.presence_penalty ?? 0).toFixed(2)}`,
      `freq ${Number(p.frequency_penalty ?? 0).toFixed(2)}`
    ];
    if(p.seed !== null && p.seed !== undefined) parts.push(`seed ${p.seed}`);
    if(Array.isArray(p.stop_sequences) && p.stop_sequences.length){
      parts.push(`stop ${p.stop_sequences.join(" | ")}`);
    }
    const paramsLine = document.createElement("div");
    paramsLine.className = "ovParams";
    paramsLine.textContent = parts.join(" · ");
    overlay.appendChild(paramsLine);

    const bars = document.createElement("div");
    bars.className = "ovBars";
    const dist = meta.dist;
    (dist.tokens || []).forEach(t => {
      const isInvalid = (t.valid === false);
      const row = document.createElement("div");
      row.className = "ovRow";
      if(!isInvalid) row.classList.add("pickable");
      if(t.kept === false) row.classList.add("cut");
      if(isInvalid) row.classList.add("invalid");
      if(meta.selected_id !== null && meta.selected_id !== undefined && t.id === meta.selected_id){
        row.classList.add("selected");
      }
      if(isInvalid){
        row.title = "Invalid under active constraint";
      }else{
        row.addEventListener("click", (e) => {
          e.stopPropagation();
          replaceCompletionAtIndex(completionIndex, t, meta);
        });
      }

      const tok = document.createElement("div");
      tok.className = "ovTok";
      if(t.special) tok.classList.add("special");
      tok.textContent = t.display;

      const wrap = document.createElement("div");
      wrap.className = "ovBarWrap";
      const bar = document.createElement("div");
      bar.className = "ovBar";
      bar.style.width = (Math.max(0, Math.min(1, t.p_final || 0)) * 100).toFixed(2) + "%";
      wrap.appendChild(bar);

      const prob = document.createElement("div");
      prob.className = "ovProb";
      prob.textContent = fmtProb(t.p_final);

      row.appendChild(tok);
      row.appendChild(wrap);
      row.appendChild(prob);
      bars.appendChild(row);
    });

      if(dist.other_p_final !== null && dist.other_p_final !== undefined){
        const row = document.createElement("div");
        row.className = "ovRow cut";
      const tok = document.createElement("div");
      tok.className = "ovTok";
      tok.textContent = "Other";
      const wrap = document.createElement("div");
      wrap.className = "ovBarWrap";
      const bar = document.createElement("div");
      bar.className = "ovBar";
      bar.style.width = (Math.max(0, Math.min(1, dist.other_p_final || 0)) * 100).toFixed(2) + "%";
      wrap.appendChild(bar);
      const prob = document.createElement("div");
      prob.className = "ovProb";
      prob.textContent = fmtProb(dist.other_p_final);
      row.appendChild(tok);
      row.appendChild(wrap);
      row.appendChild(prob);
      bars.appendChild(row);
    }

    overlay.appendChild(bars);

    overlay.classList.add("visible");
    positionOverlay(el, overlay);
  }

  function positionOverlay(el, overlay){
    const viz = $("viz");
    const vizRect = viz.getBoundingClientRect();
    const r = el.getBoundingClientRect();
    const overlayRect = overlay.getBoundingClientRect();
    const pad = 12;

    let left = r.right - vizRect.left + pad;
    let top = r.top - vizRect.top - 6;

    if(left + overlayRect.width > vizRect.width - pad){
      left = r.left - vizRect.left - overlayRect.width - pad;
    }
    if(left < pad) left = pad;
    if(top + overlayRect.height > vizRect.height - pad){
      top = vizRect.height - overlayRect.height - pad;
    }
    if(top < pad) top = pad;

    overlay.style.left = `${left}px`;
    overlay.style.top = `${top}px`;
  }

  function curvePath(x1, y1, x2, y2, minDx=32, tension=0.55, bend=0){
    const delta = Math.abs(x2 - x1);
    if(delta < 2){
      return `M ${x1} ${y1} L ${x2} ${y2}`;
    }
    const dir = x2 >= x1 ? 1 : -1;
    const dx = Math.min(Math.max(minDx, delta * tension), delta * 0.5);
    const c1x = x1 + dir * dx;
    const c2x = x2 - dir * dx;
    const c1y = y1 + bend;
    const c2y = y2 + bend;
    return `M ${x1} ${y1} C ${c1x} ${c1y}, ${c2x} ${c2y}, ${x2} ${y2}`;
  }

  function drawWires(){
    const svg = $("wires");
    const viz = $("viz");
    const activeBranchEl = document.querySelector('.branch.active');
    const stackCard = $("tokenStackCard");
    const llmEl = document.querySelector(".llm");

    if(!activeBranchEl || !stackCard || !llmEl){
      svg.innerHTML = "";
      return;
    }

    const vizRect = viz.getBoundingClientRect();
    const aRect = activeBranchEl.getBoundingClientRect();
    const llmRect = llmEl.getBoundingClientRect();

    // Starting point: right-middle of active branch card.
    const x1 = aRect.right - vizRect.left;
    const y1 = aRect.top - vizRect.top + aRect.height * 0.45;

    // Endpoints: left side of each token in stack
    const tokenEls = $("tokenStack").querySelectorAll(".stackTok");
    const paths = [];
    const tokenPoints = [];

    tokenEls.forEach((el, i) => {
      const r = el.getBoundingClientRect();
      const x2 = r.left - vizRect.left;
      const y2 = r.top - vizRect.top + r.height * 0.5;
      const xRight = r.right - vizRect.left;
      tokenPoints.push({ xLeft: x2, xRight, y: y2, i });

      const dx = Math.max(80, (x2 - x1) * 0.55);
      const c1x = x1 + dx;
      const c1y = y1;
      const c2x = x2 - dx;
      const c2y = y2;

      const d = `M ${x1} ${y1} C ${c1x} ${c1y}, ${c2x} ${c2y}, ${x2} ${y2}`;
      const opacity = 0.18 + Math.min(0.22, i * 0.012);
      paths.push(`<path d="${d}" fill="none" stroke="var(--wire)" stroke-opacity="${opacity.toFixed(3)}" stroke-width="2.2" stroke-linecap="round"/>`);
    });

    const llmLeft = llmRect.left - vizRect.left;
    const llmRight = llmRect.right - vizRect.left;
    const pad = 4;
    const stubLen = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--llm-stub')) || 54;
    const llmLeftStubEnd = llmLeft - pad;
    const llmRightStubStart = llmRight + pad;

    // Curves from tokens into fixed-width LLM stubs
    tokenPoints.forEach((p, i) => {
      const xStart = p.xRight + pad;
      const stubStart = llmLeftStubEnd - stubLen;
      const opacity = 0.16 + Math.min(0.18, i * 0.01);
      if(xStart + 1 < stubStart){
        const d = curvePath(xStart, p.y, stubStart, p.y, 28, 0.5);
        paths.push(`<path d="${d}" fill="none" stroke="var(--wire)" stroke-opacity="${opacity.toFixed(3)}" stroke-width="2" stroke-linecap="round"/>`);
      }
      const dStub = `M ${stubStart} ${p.y} L ${llmLeftStubEnd} ${p.y}`;
      paths.push(`<path d="${dStub}" fill="none" stroke="var(--wire)" stroke-opacity="${opacity.toFixed(3)}" stroke-width="2" stroke-linecap="round"/>`);
    });

    // Fixed-width LLM stubs to distribution rows
    const barsEl = $("bars");
    const barRows = barsEl ? barsEl.querySelectorAll(".barRow") : [];
    barRows.forEach((row, i) => {
      const r = row.getBoundingClientRect();
      const y = r.top - vizRect.top + r.height * 0.5;
      const xEnd = r.left - vizRect.left - pad;
      if(xEnd <= llmRightStubStart + 1) return;
      const opacity = 0.14 + Math.min(0.16, i * 0.008);
      const d = `M ${llmRightStubStart} ${y} L ${xEnd} ${y}`;
      paths.push(`<path d="${d}" fill="none" stroke="var(--wire2)" stroke-opacity="${opacity.toFixed(3)}" stroke-width="2" stroke-linecap="round"/>`);
    });

    svg.setAttribute("viewBox", `0 0 ${vizRect.width} ${vizRect.height}`);
    svg.innerHTML = paths.join("");
  }

  function selectBranch(branchId){
    if(state.activeBranchId === branchId) return;
    stopPlayback();
    clearAttribution();
    state.activeBranchId = branchId;
    renderBranches();
    renderTokenStack();
    syncControlsFromState();
    syncDecodingCollapse();
    updatePreviewDebounced(true);
  }

  function newBranch(copyFrom=null, initialPrompt=""){
    clearAttribution();
    const b = {
      id: uid(),
      prompt: (initialPrompt || ""),
      systemPrompt: DEFAULT_SYSTEM_PROMPT,
      completionIds: [],
      promptTokens: [],
      completionTokens: [],
      done: false,
      resetRng: true,
      preset: state.defaultPreset,
      params: cloneParams(state.defaultParams),
      decodingCollapsed: state.decodingCollapsedDefault,
    };
    if(copyFrom){
      b.prompt = copyFrom.prompt;
      b.systemPrompt = (typeof copyFrom.systemPrompt === "string") ? copyFrom.systemPrompt : DEFAULT_SYSTEM_PROMPT;
      b.completionIds = [...(copyFrom.completionIds || [])];
      b.promptTokens = [...(copyFrom.promptTokens || [])];
      b.completionTokens = [...(copyFrom.completionTokens || [])];
      b.done = copyFrom.done || false;
      b.resetRng = true;
      b.preset = copyFrom.preset || b.preset;
      b.params = cloneParams(copyFrom.params || b.params);
      b.decodingCollapsed = !!copyFrom.decodingCollapsed;
    }
    state.branches.push(b);
    state.activeBranchId = b.id;
    renderBranches();
    renderTokenStack();
    syncControlsFromState();
    syncDecodingCollapse();
    updatePreviewDebounced(true);
  }

  function forkBranch(branchId){
    const src = state.branches.find(b => b.id === branchId);
    if(!src) return;
    newBranch(src);
  }

  function clearActive(){
    const b = getActiveBranch();
    if(!b) return;
    stopPlayback();
    b.prompt = "";
    b.completionIds = [];
    b.promptTokens = [];
    b.completionTokens = [];
    b.done = false;
    b.resetRng = true;
    renderBranches();
    renderTokenStack();
    renderDistribution(null);
    updatePreviewDebounced(true);
  }

  let previewTimer = null;
  function updatePreviewDebounced(immediate=false){
    if(previewTimer) clearTimeout(previewTimer);
    const delay = immediate ? 0 : 220;
    previewTimer = setTimeout(() => updatePreview(), delay);
  }

  async function updateBranchTokensSoon(branchId){
    // Only preview active branch; inactive branches keep their tokens until selected.
    if(branchId !== state.activeBranchId) {
      renderBranches();
      return;
    }
    updatePreviewDebounced(false);
  }

  async function updatePreview(){
    const b = getActiveBranch();
    if(!b) return;
    clearAttribution();

    try{
      readParamsFromControls();
      // Do not let greedy be overridden by sliders; it's only via preset.
      if(getActivePreset() === "greedy") b.params.greedy = true;
      const params = b.params;

      const res = await apiPost("/api/preview", {
        branch_id: b.id,
        prompt: b.prompt,
        system_prompt: ensureSystemPrompt(b),
        use_chat_template: isChatTemplateEnabled(),
        completion_ids: b.completionIds,
        top_k: state.topK,
        params,
        constraint: getConstraintPayload()
      });

      setServerStatus(true, res.model.model_id ? "" : "—");

      // Update tokens for active branch
      b.promptTokens = res.prompt_tokens || [];
      const prevCompletion = b.completionTokens || [];
      b.completionTokens = (res.completion_tokens || []).map((t, i) => {
        const prev = prevCompletion[i] || {};
        if(prev.meta){
          return { ...t, meta: prev.meta };
        }
        t.meta = { completion_index: i };
        return t;
      });

      renderBranches();
      renderTokenStack();
      renderDistribution(state.llmEnabled ? res.dist : null);

    }catch(e){
      setServerStatus(false, String(e).slice(0,180));
      renderDistribution(null);
    }
  }

  async function forceToken(tokenId){
    const b = getActiveBranch();
    if(!b || b.done) return;
    const distToken = (state.lastDist && Array.isArray(state.lastDist.tokens))
      ? state.lastDist.tokens.find(t => Number(t.id) === Number(tokenId))
      : null;
    if(distToken && distToken.valid === false){
      setServerStatus(true, "Token is invalid for the active constraint.");
      return;
    }
    await doStep({ force_token_id: tokenId });
  }

  async function forceText(){
    if(isConstraintActive()){
      setServerStatus(true, "Force text is disabled while constrained sampling is active.");
      return;
    }
    const txt = ($("forceText").value || "");
    if(txt.trim() === "") return;
    const b = getActiveBranch();
    if(!b || b.done) return;
    $("forceText").value = "";
    await doStep({ force_text: txt });
  }

  async function doStep(extra={}){
    const b = getActiveBranch();
    if(!b || b.done) return;
    if(!state.llmEnabled){
      setServerStatus(true, "LLM is off");
      return;
    }
    if(extra.force_text && isConstraintActive()){
      setServerStatus(true, "Force text is disabled while constrained sampling is active.");
      return;
    }
    clearAttribution();

    try{
      readParamsFromControls();
      if(getActivePreset() === "greedy") b.params.greedy = true;
      const params = b.params;
      const paramsSnapshot = snapshotParams();
      const forcedBy = extra.force_text ? "text" : (extra.force_token_id !== undefined && extra.force_token_id !== null ? "token" : null);
      const forced = !!forcedBy;

      const res = await apiPost("/api/step", {
        branch_id: b.id,
        reset_rng: !!b.resetRng,
        prompt: b.prompt,
        system_prompt: ensureSystemPrompt(b),
        use_chat_template: isChatTemplateEnabled(),
        completion_ids: b.completionIds,
        top_k: state.topK,
        params,
        constraint: getConstraintPayload(),
        ...extra
      });
      b.resetRng = false;

      // Show distribution (pre-step)
      renderDistribution(res.dist, res.selected ? res.selected.id : null);

      // Append tokens
      const appended = res.appended || [];
      if(appended.length){
        // Update token ids: server returns only new_completion_ids
        b.completionIds = res.new_completion_ids || b.completionIds;
        // Also update token pills incrementally for smooth animation
        const appendedMeta = res.appended_meta || [];
        appended.forEach((t, idx) => {
          const metaFromServer = appendedMeta[idx] || null;
        const meta = {
          dist: metaFromServer?.dist || res.dist || null,
          selected_id: metaFromServer?.selected_id ?? (res.selected ? res.selected.id : (forced ? t.id : null)),
          forced: metaFromServer?.forced ?? forced,
          forced_by: metaFromServer?.forced_by ?? forcedBy,
          greedy: paramsSnapshot.greedy,
          params: paramsSnapshot,
          top_k: paramsSnapshot.top_k,
          completion_index: b.completionTokens.length + idx,
        };
          b.completionTokens.push({ ...t, _new:true, meta });
        });
      }

      // Update UI
      renderBranches();
      renderTokenStack();
      // Mark new tokens with animation class in the branch card
      markNewTokenAnimations();

      if(res.done){
        b.done = true;
        stopPlayback();
        setServerStatus(true, "Stopped: " + (res.stop_reason || "done"));
        return;
      }

      // Fetch next distribution (post-step) to keep bars moving
      setTimeout(() => updatePreviewDebounced(true), 180);

    }catch(e){
      stopPlayback();
      setServerStatus(false, String(e).slice(0,180));
    }
  }

  function markNewTokenAnimations(){
    // Add a brief animation class to newly appended completion tokens in branch cards.
    const active = document.querySelector('.branch.active');
    if(!active) return;
    const toks = active.querySelectorAll('.tok.gen');
    // Mark the last few tokens as new based on state data
    const b = getActiveBranch();
    if(!b) return;
    const nNew = (b.completionTokens || []).filter(t => t._new).length;
    if(nNew <= 0) return;
    // Apply class to last nNew gen tokens
    for(let i=toks.length - nNew; i<toks.length; i++){
      if(i>=0 && toks[i]) toks[i].classList.add("newTok");
    }
    // Clear _new flags
    (b.completionTokens || []).forEach(t => { delete t._new; });
  }

  async function playLoop(){
    if(!state.playing) return;
    await doStep();
    if(!state.playing) return;
    state.playTimer = setTimeout(playLoop, state.stepSpeedMs);
  }

  function togglePlay(){
    const b = getActiveBranch();
    if(!b) return;
    if(!state.llmEnabled){
      setServerStatus(true, "LLM is off");
      return;
    }
    if(b.done){
      setServerStatus(true, "This branch is done. Edit the prompt or fork to continue.");
      return;
    }
    state.playing = !state.playing;
    if(state.playing){
      $("playBtnLabel").textContent = "Pause";
      $("playBtn").querySelector("svg").innerHTML = '<path d="M7 6h3v12H7V6Zm7 0h3v12h-3V6Z" fill="currentColor"/>';
      playLoop();
    }else{
      stopPlayback();
    }
  }

  function wireEvents(){
    $("loadModelBtn").addEventListener("click", async () => {
      stopPlayback();
      const id = ($("modelId").value || "").trim();
      if(!id) return;
      try{
        await apiPost("/api/model/load", { model_id: id });
        setModelStatus({loading:true,ready:false,error:null,model_id:id});
        const st = await pollModelReady();
        if(st.model_id) writeStorage(STORAGE_KEYS.modelId, st.model_id);
        updatePreviewDebounced(true);
      }catch(e){
        setServerStatus(false, String(e).slice(0,180));
      }
    });
    const chatToggle = $("useChatTemplate");
    if(chatToggle){
      chatToggle.addEventListener("change", () => {
        setChatTemplateEnabled(chatToggle.checked);
      });
    }

    $("newBranchBtn").addEventListener("click", () => newBranch());
    $("clearBtn").addEventListener("click", () => clearActive());

    // Presets
    $("presetButtons").querySelectorAll(".btn").forEach(btn => {
      btn.addEventListener("click", () => {
        const p = btn.dataset.preset;
        const b = getActiveBranch();
        if(!b) return;
        if(p === "greedy"){
          b.params.greedy = true;
          applyPreset("greedy");
          return;
        }
        b.params.greedy = false;
        applyPreset(p);
      });
    });

    // Sliders + inputs
    ["temperature","topP","repetitionPenalty"].forEach(id => {
      $(id).addEventListener("input", () => {
        markCustomPreset();
        readParamsFromControls();
        $("temperatureVal").textContent = Number($("temperature").value).toFixed(2);
        $("topPVal").textContent = Number($("topP").value).toFixed(2);
        $("repetitionPenaltyVal").textContent = Number($("repetitionPenalty").value).toFixed(2);
        updatePreviewDebounced(false);
      });
    });

    ["presencePenalty","frequencyPenalty","seed","stopSeq"].forEach(id => {
      $(id).addEventListener("input", () => {
        markCustomPreset();
        readParamsFromControls();
        // Reset RNG when seed changes
        const b = getActiveBranch();
        if(b) b.resetRng = true;
        updatePreviewDebounced(false);
      });
    });

    $("topK").addEventListener("input", () => {
      state.topK = Math.max(1, Math.min(50, Number($("topK").value || 10)));
      writeStorage(STORAGE_KEYS.topK, String(state.topK));
      updatePreviewDebounced(true);
    });

    $("stepSpeed").addEventListener("input", () => {
      state.stepSpeedMs = Math.max(80, Number($("stepSpeed").value || 650));
      $("stepSpeedVal").textContent = state.stepSpeedMs + " ms";
      writeStorage(STORAGE_KEYS.stepSpeedMs, String(state.stepSpeedMs));
    });

    $("attrMethod").addEventListener("change", () => {
      setAttrMethod($("attrMethod").value);
    });
    $("constraintEnabled").addEventListener("change", () => {
      setConstraintEnabled($("constraintEnabled").checked);
    });
    $("constraintType").addEventListener("change", () => {
      setConstraintType($("constraintType").value);
    });
    $("constraintSchema").addEventListener("input", () => {
      setConstraintSchema($("constraintSchema").value);
    });

    $("forceBtn").addEventListener("click", forceText);
    $("forceText").addEventListener("keydown", (e) => {
      if(e.key === "Enter"){
        e.preventDefault();
        forceText();
      }
    });

    $("playBtn").addEventListener("click", togglePlay);
    $("stepBtn").addEventListener("click", () => doStep());

    $("llmBox").addEventListener("click", () => {
      setLlmEnabled(!state.llmEnabled);
    });

    window.addEventListener("resize", () => requestAnimationFrame(drawWires));
    $("tokenStack").addEventListener("scroll", () => requestAnimationFrame(drawWires));
    $("bars").addEventListener("scroll", () => requestAnimationFrame(drawWires));
    $("branches").addEventListener("scroll", () => requestAnimationFrame(drawWires));

    const overlay = $("tokenOverlay");
    overlay.addEventListener("mouseenter", () => {
      if(overlayHideTimer) clearTimeout(overlayHideTimer);
    });
    overlay.addEventListener("mouseleave", scheduleHideOverlay);

    $("promptLibraryClose").addEventListener("click", closePromptLibrary);
    $("promptLibrary").addEventListener("click", (e) => {
      if(e.target.id === "promptLibrary") closePromptLibrary();
    });
    window.addEventListener("keydown", (e) => {
      if(e.key === "Escape") closePromptLibrary();
    });

    document.querySelectorAll(".cardToggle").forEach(btn => {
      btn.addEventListener("click", () => {
        const targetId = btn.dataset.target;
        const body = targetId ? $(targetId) : null;
        if(!body) return;
        const card = body.closest(".card");
        if(targetId === "decodingCard"){
          const b = getActiveBranch();
          if(!b) return;
          b.decodingCollapsed = !b.decodingCollapsed;
          state.decodingCollapsedDefault = b.decodingCollapsed;
          writeBool(STORAGE_KEYS.decodingCollapsed, state.decodingCollapsedDefault);
          setCardCollapsed(card, b.decodingCollapsed, btn);
          return;
        }
        if(targetId === "speedCard"){
          state.stepSpeedCollapsed = !state.stepSpeedCollapsed;
          writeBool(STORAGE_KEYS.stepSpeedCollapsed, state.stepSpeedCollapsed);
          setCardCollapsed(card, state.stepSpeedCollapsed, btn);
          return;
        }
        if(targetId === "constraintCard"){
          state.constraintCollapsed = !state.constraintCollapsed;
          writeBool(STORAGE_KEYS.constraintCollapsed, state.constraintCollapsed);
          setCardCollapsed(card, state.constraintCollapsed, btn);
          return;
        }
        if(targetId === "attrCard"){
          state.attrCollapsed = !state.attrCollapsed;
          writeBool(STORAGE_KEYS.attrCollapsed, state.attrCollapsed);
          setCardCollapsed(card, state.attrCollapsed, btn);
        }
      });
    });
  }

  async function init(){
    loadStoredSettings();
    const storedModel = readStorage(STORAGE_KEYS.modelId, null);
    $("modelId").value = storedModel || "Qwen/Qwen2.5-0.5B-Instruct";
    $("topK").value = state.topK;
    $("stepSpeed").value = state.stepSpeedMs;
    $("stepSpeedVal").textContent = state.stepSpeedMs + " ms";

    wireEvents();
    syncConstraintUi();

    // Initial branch (pre-filled for the live demo)
    newBranch(null, "The capital of France is");

    syncSpeedCollapse();
    syncConstraintCollapse();
    syncAttrCollapse();
    setLlmEnabled(state.llmEnabled);

    // Poll model status
    try{
      const st = await pollModelReady();
      $("modelId").value = st.model_id || $("modelId").value;
      if(st.model_id) writeStorage(STORAGE_KEYS.modelId, st.model_id);
      setServerStatus(true, "Ready");
      updatePreviewDebounced(true);
    }catch(e){
      setServerStatus(false, String(e).slice(0,180));
    }
  }

  init();
})();
</script>
</body>
</html>
